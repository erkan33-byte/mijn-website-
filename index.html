<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<title>BTC Key Generator Incremental / Random</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.4/elliptic.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
<style>
body { font-family: Arial, sans-serif; padding: 20px; }
table { border-collapse: collapse; width: 100%; margin-top: 15px; }
th, td { border: 1px solid #ccc; padding: 8px; font-size: 14px; word-break: break-all; }
th { background: #f2f2f2; }
button, select, input { margin-bottom: 10px; padding: 8px 12px; }
#totaal, #errors, #progress { margin-bottom: 10px; font-weight: bold; }
#retryMsg { margin-top: 15px; font-weight: bold; color: orange; font-size: 16px; animation: blink 1s infinite; }
#foundMsg { margin-top: 15px; font-weight: bold; font-size: 16px; color: green; }
@keyframes blink { 0%,50%,100% {opacity:1;} 25%,75% {opacity:0;} }
label { display:inline-block; min-width: 210px; }
</style>
</head>
<body>
<h2>BTC Key Generator (incremental/random, max 50 zichtbaar)</h2>

<div id="totaal">Totaal gescande adressen: 0</div>
<div id="errors">Aantal errors: 0</div>
<div id="progress">Voortgang in keyspace: 0.000%</div>

<label for="modeSelect">Modus:</label>
<select id="modeSelect" title="Kies hoe keys worden gegenereerd">
  <option value="inc-random-start">Incremental (random start per refresh)</option>
  <option value="inc-percent-start">Incremental (start % van keyspace)</option>
  <option value="random-each-step">Random (elke stap nieuwe key)</option>
</select>
<br>

<label for="startPercent">Start percentage (0–100) — alleen voor 'Incremental (start %)': </label>
<input type="number" id="startPercent" value="0" min="0" max="100" step="0.0001">
<br>

<label for="batchRate">Batches per seconde:</label>
<input type="number" id="batchRate" value="5" min="1" max="20">
<br>

<button id="startBtn">Start zoeken</button>
<button id="stopBtn" disabled>Stop</button>
<button onclick="resetTeller()">Reset teller</button>
<button onclick="resetErrors()">Reset errors</button>

<div id="retryMsg"></div>
<div id="foundMsg"></div>

<table id="resultTable">
  <thead>
    <tr><th>#</th><th>Adres</th><th>Private Key (WIF)</th><th>Saldo (BTC)</th></tr>
  </thead>
  <tbody></tbody>
</table>

<script>
// ======== Basisfuncties ========
function toHex(bytes){return Array.from(bytes).map(b=>b.toString(16).padStart(2,"0")).join("");}
function hexToBytes(hex){const out=new Uint8Array(hex.length/2);for(let i=0;i<out.length;i++) out[i]=parseInt(hex.substr(i*2,2),16);return out;}
function sha256Hex(hex){return CryptoJS.SHA256(CryptoJS.enc.Hex.parse(hex)).toString();}
function doubleSha256Hex(hex){return sha256Hex(sha256Hex(hex));}
function base58Encode(hex){
  const alphabet="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  const bytes=hexToBytes(hex);
  let zeros=0; while(zeros<bytes.length&&bytes[zeros]===0) zeros++;
  let num=BigInt("0x"+hex);
  let out=""; while(num>0n){let r=num%58n; num/=58n; out=alphabet[Number(r)]+out;}
  return "1".repeat(zeros)+(out||"");
}

// ======== Echte keyspace (secp256k1 order n) ========
const ORDER_N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141n; // secp256k1
const MIN_KEY = 1n;
const MAX_VALID_KEY = ORDER_N - 1n;         // hoogste geldige private key
const KEYSPACE_SIZE = MAX_VALID_KEY;        // aantal geldige keys (1..n-1)
const STEPS_PER_100_PERCENT = 100000n;      // 0,001% per stap

// Voor exacte 0,001%-stapgrootte per stap gebruiken we een accumulator:
// na elke stap verhogen we de key met floor(KEYSPACE_SIZE / 100000) en verdelen we de rest exact.
let carryNum = 0n; // accumulator voor (stappen * KEYSPACE_SIZE) mod 100000

function genRandomKeyBigInt(){
  // Uniform-ish in 1..MAX_VALID_KEY (met modulo +1; licht bias is ok voor dit gebruik)
  const arr=new Uint8Array(32);
  crypto.getRandomValues(arr);
  const hex=Array.from(arr,b=>b.toString(16).padStart(2,"0")).join("");
  let k=BigInt("0x"+hex);
  if(k===0n) return 1n;
  if(k>MAX_VALID_KEY) k = (k % MAX_VALID_KEY) + 1n;
  return k;
}

// Map 0..100% (met 0,001%-stappen) naar key op exacte stap-grid
function percentToKey(perc){
  const steps = BigInt(Math.round(Math.min(100,Math.max(0,perc)) * 1000)); // 0..100000
  const delta = (KEYSPACE_SIZE * steps) / STEPS_PER_100_PERCENT;            // floor
  return MIN_KEY + delta; // in [1..MAX_VALID_KEY]
}

// ======== Variabelen ========
let counter=0;
let totaal=parseInt(localStorage.getItem("totaal")||"0",10);
let fouten=parseInt(localStorage.getItem("fouten")||"0",10);
let zoeken=false;
const MAX_VISIBLE=50;
let BATCH_SIZE=2;

let mode="inc-random-start";
let currentKey=null;
let firstKey=null;

// voortgang in 0,001%-stappen t.o.v. 0% baseline
let stepsDone = 0n;      // hoeveel 0,001%-stappen sinds start van de run
let startSteps = 0n;     // start-offset in 0,001%-stappen (bijv. bij start%)

// UI init
document.getElementById("totaal").textContent="Totaal gescande adressen: "+totaal;
document.getElementById("errors").textContent="Aantal errors: "+fouten;
document.getElementById("modeSelect").addEventListener("change",(e)=>{mode=e.target.value;});
mode=document.getElementById("modeSelect").value;
firstKey=genRandomKeyBigInt();
currentKey=firstKey;

// ======== Balance check met 7 API’s ========
async function checkBalance(address){
  const apis=[
    `https://corsproxy.io/?url=https://blockstream.info/api/address/${address}`,
    `https://corsproxy.io/?url=https://mempool.space/api/address/${address}`,
    `https://corsproxy.io/?url=https://blockchain.info/rawaddr/${address}?cors=true`,
    `https://api.blockchair.com/bitcoin/dashboards/address/${address}`,
    `https://sochain.com/api/v2/address/BTC/${address}`,
    `https://btcscan.org/api/address/${address}`,
    `https://api.smartbit.com.au/v1/blockchain/address/${address}`
  ];

  for(let url of apis){
    try{
      const controller=new AbortController();
      const timeout=setTimeout(()=>controller.abort(),3000);
      const resp=await fetch(url,{signal:controller.signal});
      clearTimeout(timeout);
      if(!resp.ok) continue;
      const data=await resp.json();
      if(data.chain_stats){
        const funded=Number(data.chain_stats.funded_txo_sum||0);
        const spent=Number(data.chain_stats.spent_txo_sum||0);
        return (funded-spent)/1e8;
      }
      if(typeof data.final_balance!=="undefined") return data.final_balance/1e8;
      if(data.data && data.data[address] && data.data[address].address) return data.data[address].address.balance/1e8;
    }catch(e){ continue; }
  }
  fouten++;
  localStorage.setItem("fouten",fouten);
  document.getElementById("errors").textContent="Aantal errors: "+fouten;
  return "Error";
}

// ======== Helper: volgende incrementele stap = +0,001% ========
function doOneIncrementalStep(){
  // Accumuleer exact: na s stappen is delta = floor(s * KEYSPACE_SIZE / 100000)
  carryNum += KEYSPACE_SIZE;
  const inc = carryNum / STEPS_PER_100_PERCENT; // BigInt
  carryNum %= STEPS_PER_100_PERCENT;

  currentKey += inc;
  if(currentKey > MAX_VALID_KEY) currentKey -= KEYSPACE_SIZE; // wrap binnen [1..n-1]

  stepsDone += 1n;
}

// ======== Genereer batch ========
async function genereerBatch(){
  if(!zoeken) return;
  const keys=[];
  for(let i=0;i<BATCH_SIZE;i++){
    let k;
    if(mode==="random-each-step"){
      k = genRandomKeyBigInt();
    }else{
      k = currentKey;          // pak huidige key
      doOneIncrementalStep();  // schuif alvast door voor de volgende (0,001%)
    }
    keys.push(k);
  }

  const addresses=keys.flatMap(k=>{
    const privHex=k.toString(16).padStart(64,"0");
    const ec=new elliptic.ec("secp256k1");
    const kp=ec.keyFromPrivate(privHex,"hex");

    // Compressed
    const pubC=toHex(kp.getPublic(true,"array"));
    const ripemdC=CryptoJS.RIPEMD160(CryptoJS.enc.Hex.parse(sha256Hex(pubC))).toString();
    const payloadC="00"+ripemdC;
    const checksumC=doubleSha256Hex(payloadC).slice(0,8);
    const addressC=base58Encode(payloadC+checksumC);
    const wifC=base58Encode("80"+privHex+"01"+doubleSha256Hex("80"+privHex+"01").slice(0,8));

    // Uncompressed
    const pubU=toHex(kp.getPublic(false,"array"));
    const ripemdU=CryptoJS.RIPEMD160(CryptoJS.enc.Hex.parse(sha256Hex(pubU))).toString();
    const payloadU="00"+ripemdU;
    const checksumU=doubleSha256Hex(payloadU).slice(0,8);
    const addressU=base58Encode(payloadU+checksumU);
    const wifU=base58Encode("80"+privHex+doubleSha256Hex("80"+privHex).slice(0,8));

    return [{address:addressC,wif:wifC},{address:addressU,wif:wifU}];
  });

  const saldi=await Promise.all(addresses.map(a=>checkBalance(a.address)));

  const tbody=document.querySelector("#resultTable tbody");
  for(let i=0;i<addresses.length;i++){
    counter++; totaal++;
    let saldo=saldi[i];
    if(saldo==="Error") saldo="Error";
    let row=document.createElement("tr");
    row.innerHTML=`<td>${counter}</td><td>${addresses[i].address}</td><td>${addresses[i].wif}</td><td>${saldo}</td>`;
    if(typeof saldo==="number" && saldo>0){
      row.style.backgroundColor="#c8f7c5";
      document.getElementById("foundMsg").textContent=`Adres gevonden met saldo >0 BTC! ${addresses[i].address} | WIF: ${addresses[i].wif}`;
      stoppen();
    }
    tbody.appendChild(row);
  }
  while(tbody.rows.length>MAX_VISIBLE) tbody.deleteRow(0);
  localStorage.setItem("totaal",totaal);
  document.getElementById("totaal").textContent="Totaal gescande adressen: "+totaal;

  // ======== Voortgangsupdate ========
  // We tonen de voortgang binnen 0..100% op een raster van 0,001% (100000 stappen).
  const stepsDisplay = (startSteps + stepsDone) % STEPS_PER_100_PERCENT; // cyclisch
  const perc = Number(stepsDisplay) / 1000; // 0,001% per stap
  document.getElementById("progress").textContent = "Voortgang in keyspace: " + perc.toFixed(3) + " %";

  const rate=parseInt(document.getElementById("batchRate").value)||5;
  const interval=1000/rate;
  if(zoeken) setTimeout(genereerBatch,interval);
}

// ======== Start / stop / reset ========
function starten(){
  if(zoeken) return;
  const selected=document.getElementById("modeSelect").value; mode=selected;

  // reset stap-accu en voortgang
  carryNum = 0n;
  stepsDone = 0n;
  startSteps = 0n;

  if(mode==="inc-random-start"){
    firstKey=genRandomKeyBigInt();
    currentKey=firstKey;

    // Stel startSteps gelijk aan de positie van firstKey in 0,001%-grid
    // steps = floor((k-1)/keyspace * 100000)
    startSteps = ((currentKey - MIN_KEY) * STEPS_PER_100_PERCENT) / KEYSPACE_SIZE;

  }else if(mode==="inc-percent-start"){
    const perc=parseFloat(document.getElementById("startPercent").value)||0;
    // start exact op de 0,001%-grid
    currentKey = percentToKey(Math.min(100,Math.max(0,perc)));
    startSteps = BigInt(Math.round(Math.min(100,Math.max(0,perc)) * 1000));
  }else{
    // random-each-step gebruikt eigen random keys
    currentKey = genRandomKeyBigInt();
  }

  zoeken=true;
  document.getElementById("startBtn").disabled=true;
  document.getElementById("stopBtn").disabled=false;
  document.getElementById("retryMsg").textContent="";
  document.getElementById("foundMsg").textContent="";
  genereerBatch();
}

function stoppen(){
  zoeken=false;
  document.getElementById("startBtn").disabled=false;
  document.getElementById("stopBtn").disabled=true;
}

function resetTeller(){
  totaal=0;
  localStorage.setItem("totaal",totaal);
  document.getElementById("totaal").textContent="Totaal gescande adressen: 0";
}

function resetErrors(){
  fouten=0;
  localStorage.setItem("fouten",fouten);
  document.getElementById("errors").textContent="Aantal errors: 0";
}

document.getElementById("startBtn").addEventListener("click", starten);
document.getElementById("stopBtn").addEventListener("click", stoppen);
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<title>BTC Key Generator + Balance Check</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.4/elliptic.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/bs58/5.0.0/bs58.min.js"></script>
<style>
body { font-family: Arial, sans-serif; background: #111; color: #eee; text-align: center; }
h2 { color: #6cf; }
table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 12px; }
th, td { border: 1px solid #444; padding: 4px; }
tr.highlight { background-color: #006400; color: #fff; font-weight: bold; }
#status { margin: 10px; font-weight: bold; }
</style>
</head>
<body>
<h2>BTC Key Generator + Balance Check</h2>
<div id="status">Nog niet gestart</div>
<button onclick="start()">Start zoeken</button>
<button onclick="stop()">Stop</button>
<button onclick="resetCount()">Reset teller</button>
<button onclick="resetErrors()">Reset errors</button>
<br><br>
<label>Snelheid:
<select id="speed">
<option value="1">1 adres/sec</option>
<option value="5">5 adressen/sec</option>
<option value="10">10 adressen/sec</option>
<option value="50">50 adressen/sec</option>
<option value="100">100 adressen/sec</option>
</select>
</label>
<p>Gescande adressen: <span id="count">0</span> | Errors: <span id="errors">0</span></p>
<table id="results">
<tr>
<th>#</th><th>Adres</th><th>Private Key (WIF)</th><th>Saldo (BTC)</th>
</tr>
</table>

<script>
let running = false;
let counter = parseInt(localStorage.getItem("counter")||"0");
let errors = parseInt(localStorage.getItem("errors")||"0");
document.getElementById("count").textContent = counter;
document.getElementById("errors").textContent = errors;
let loop;

// Helper functies
function sha256(buffer){ return CryptoJS.SHA256(CryptoJS.enc.Hex.parse(buffer.toString("hex"))); }
function ripemd160(buffer){ return CryptoJS.RIPEMD160(CryptoJS.enc.Hex.parse(buffer.toString("hex"))); }
function base58check(payload){ 
  let hash = sha256(CryptoJS.enc.Hex.parse(payload.toString("hex")));
  hash = sha256(hash);
  const checksum = Buffer.from(hash.toString(CryptoJS.enc.Hex),"hex").slice(0,4);
  return bs58.encode(Buffer.concat([payload, checksum]));
}
function privateToWIF(privKey, compressed=true){
  let prefix = Buffer.from([0x80]);
  let keyBuffer = Buffer.concat([prefix, privKey]);
  if(compressed){ keyBuffer = Buffer.concat([keyBuffer, Buffer.from([0x01])]); }
  return base58check(keyBuffer);
}
function pubkeyToAddress(pubkey){
  let sha = sha256(Buffer.from(pubkey.toString("hex"),"hex"));
  let ripe = ripemd160(Buffer.from(sha.toString(CryptoJS.enc.Hex),"hex"));
  let payload = Buffer.concat([Buffer.from([0x00]), Buffer.from(ripe.toString(CryptoJS.enc.Hex),"hex")]);
  return base58check(payload);
}

// Balance check met retry
async function checkBalance(address){
  const urls = [
    `https://corsproxy.io/?url=https://blockstream.info/api/address/${address}`,
    `https://corsproxy.io/?url=https://mempool.space/api/address/${address}`,
    `https://corsproxy.io/?url=https://blockchain.info/rawaddr/${address}?cors=true`,
    `https://corsproxy.io/?url=https://btcscan.org/api/address/${address}`,
    `https://corsproxy.io/?url=https://api.blockchair.com/bitcoin/dashboards/address/${address}`,
    `https://api.allorigins.win/raw?url=https://blockstream.info/api/address/${address}`,
    `https://api.allorigins.win/raw?url=https://mempool.space/api/address/${address}`
  ];

  async function tryOnce(){
    const promises = urls.map(url =>
      fetch(url).then(resp=>resp.json()).then(data=>{
        if(data.chain_stats) return (Number(data.chain_stats.funded_txo_sum||0) - Number(data.chain_stats.spent_txo_sum||0))/1e8;
        if(typeof data.final_balance!=="undefined") return data.final_balance/1e8;
        if(data.data && data.data[address]) return Number(data.data[address].address.balance||0)/1e8;
        throw new Error("Onbekend antwoord");
      })
    );
    try { return await Promise.any(promises); }
    catch(e){ return "Error"; }
  }

  let attempt=0;
  while(running){
    let balance = await tryOnce();
    if(balance!=="Error") return balance;
    attempt++;
    document.getElementById("status").textContent = `Saldo-check mislukt (poging ${attempt}) voor ${address}. Opnieuw in 1s...`;
    await new Promise(r=>setTimeout(r,1000));
  }
  return "Aborted";
}

// Adres genereren
async function generate(){
  const ec = new elliptic.ec("secp256k1");
  const key = ec.genKeyPair();
  const priv = key.getPrivate().toArrayLike(Buffer,"be",32);

  // Compressed
  const pubC = key.getPublic(true,"array");
  const addrC = pubkeyToAddress(Buffer.from(pubC));
  const wifC = privateToWIF(priv,true);

  // Uncompressed
  const pubU = key.getPublic(false,"array");
  const addrU = pubkeyToAddress(Buffer.from(pubU));
  const wifU = privateToWIF(priv,false);

  let balanceC = await checkBalance(addrC);
  let balanceU = await checkBalance(addrU);

  counter++; localStorage.setItem("counter",counter); 
  document.getElementById("count").textContent = counter;

  if(balanceC==="Error" && balanceU==="Error"){ errors++; localStorage.setItem("errors",errors); document.getElementById("errors").textContent=errors; }

  const table = document.getElementById("results");
  function addRow(addr,wif,balance){
    let row = table.insertRow(1);
    row.insertCell(0).textContent = counter;
    row.insertCell(1).textContent = addr;
    row.insertCell(2).textContent = wif;
    row.insertCell(3).textContent = balance;
    if(balance>0){ 
      row.classList.add("highlight");
      document.getElementById("status").textContent = `ðŸŽ‰ Adres gevonden met saldo > 0 BTC! WIF: ${wif}`;
      stop();
    }
  }

  addRow(addrC,wifC,balanceC);
  addRow(addrU,wifU,balanceU);

  while(table.rows.length>501){ table.deleteRow(-1); }
}

// Besturing
function start(){
  if(running) return;
  running = true;
  document.getElementById("status").textContent = "Zoeken gestart...";
  let speed = parseInt(document.getElementById("speed").value);
  loop = setInterval(()=>{ if(running) generate(); },1000/speed);
}
function stop(){ running=false; clearInterval(loop); document.getElementById("status").textContent="Gestopt"; }
function resetCount(){ counter=0; localStorage.setItem("counter",0); document.getElementById("count").textContent=0; }
function resetErrors(){ errors=0; localStorage.setItem("errors",0); document.getElementById("errors").textContent=0; }
</script>
</body>
</html>

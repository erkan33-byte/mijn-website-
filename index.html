<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<title>BTC Key Generator Incremental / Random</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.4/elliptic.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
<style>
body { font-family: Arial, sans-serif; padding: 20px; }
table { border-collapse: collapse; width: 100%; margin-top: 15px; }
th, td { border: 1px solid #ccc; padding: 8px; font-size: 14px; word-break: break-all; }
th { background: #f2f2f2; }
button, select, input { margin-bottom: 10px; padding: 8px 12px; }
#totaal, #errors, #progress { margin-bottom: 10px; font-weight: bold; }
#retryMsg { margin-top: 15px; font-weight: bold; color: orange; font-size: 16px; animation: blink 1s infinite; }
#foundMsg { margin-top: 15px; font-weight: bold; font-size: 16px; color: green; }
@keyframes blink { 0%,50%,100% {opacity:1;} 25%,75% {opacity:0;} }
label { display:inline-block; min-width: 210px; }
</style>
</head>
<body>
<h2>BTC Key Generator (random start, incremental, max 50 zichtbaar)</h2>

<p>
  <a href="index3.html" target="_blank" style="font-weight:bold; font-size:16px; color:blue; text-decoration:underline;">
    Ga naar index3.html
  </a>
</p>

<div id="totaal">Totaal gescande adressen: 0</div>
<div id="errors">Aantal errors: 0</div>
<div id="progress">Voortgang in keyspace: 0.0000000000 %</div>

<label for="stepKeys">Stapgrootte (aantal sleutels per stap, bijv. 1000000):</label>
<input type="text" id="stepKeys" value="1000000">
<br>

<label for="batchSize">Aantal sleutels per batch (voor UI/API):</label>
<input type="number" id="batchSize" value="5" min="1" max="20">
<br>

<label for="batchRate">Batches per seconde:</label>
<input type="number" id="batchRate" value="5" min="1" max="20">
<br>

<button id="startBtn">Start zoeken</button>
<button id="stopBtn" disabled>Stop</button>
<button onclick="resetTeller()">Reset teller</button>
<button onclick="resetErrors()">Reset errors</button>

<div id="retryMsg"></div>
<div id="foundMsg"></div>

<table id="resultTable">
  <thead>
    <tr>
      <th>#</th>
      <th>Compressed Adres</th>
      <th>Compressed WIF</th>
      <th>Uncompressed Adres</th>
      <th>Uncompressed WIF</th>
      <th>Saldo (BTC)</th>
    </tr>
  </thead>
  <tbody></tbody>
</table>

<script>
// ======== Helper functies ========
function toHex(bytes){return Array.from(bytes).map(b=>b.toString(16).padStart(2,"0")).join("");}
function hexToBytes(hex){const out=new Uint8Array(hex.length/2);for(let i=0;i<out.length;i++) out[i]=parseInt(hex.substr(i*2,2),16);return out;}
function sha256Hex(hex){return CryptoJS.SHA256(CryptoJS.enc.Hex.parse(hex)).toString();}
function doubleSha256Hex(hex){return sha256Hex(sha256Hex(hex));}
function base58Encode(hex){
  const alphabet="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  const bytes=hexToBytes(hex);
  let zeros=0; while(zeros<bytes.length&&bytes[zeros]===0) zeros++;
  let num=BigInt("0x"+hex);
  let out=""; while(num>0n){let r=num%58n; num/=58n; out=alphabet[Number(r)]+out;}
  return "1".repeat(zeros)+(out||"");
}

// ======== Keyspace ========
const ORDER_N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141n;
const MIN_KEY = 1n;
const MAX_VALID_KEY = ORDER_N - 1n;
const KEYSPACE_SIZE = MAX_VALID_KEY;

// ======== Random key ========
function genRandomKeyBigInt(){
  const arr=new Uint8Array(32);
  crypto.getRandomValues(arr);
  const hex=Array.from(arr,b=>b.toString(16).padStart(2,"0")).join("");
  let k=BigInt("0x"+hex);
  if(k===0n) return 1n;
  if(k>MAX_VALID_KEY) k = (k % MAX_VALID_KEY) + 1n;
  return k;
}

// ======== Variabelen ========
let counter=0, totaal=parseInt(localStorage.getItem("totaal")||"0",10), fouten=parseInt(localStorage.getItem("fouten")||"0",10);
let zoeken=false, MAX_VISIBLE=250;
let currentKey=null, stepKeys=1n, batchSize=5;
let proxyIndex = 0;

// ======== Proxies ========
const proxies=[
  "https://corsproxy.io/?url=",
  "https://api.allorigins.win/raw?url=",
  "https://thingproxy.freeboard.io/fetch/",
  "https://cors.bridged.cc/",
  "https://cors-anywhere.herokuapp.com/"
];

// ======== Balance APIs ========
const balanceAPIs=[
  {url: addr=>`https://blockstream.info/api/address/${addr}`, parser: data => (Number(data.chain_stats.funded_txo_sum||0)-Number(data.chain_stats.spent_txo_sum||0))/1e8 },
  {url: addr=>`https://mempool.space/api/address/${addr}`, parser: data => (Number(data.chain_stats.funded_txo_sum||0)-Number(data.chain_stats.spent_txo_sum||0))/1e8 },
  {url: addr=>`https://blockchain.info/rawaddr/${addr}?cors=true`, parser: data => Number(data.final_balance)/1e8 },
  {url: addr=>`https://api.blockchair.com/bitcoin/dashboards/address/${addr}`, parser: data => Number(data.data[addr].address.balance)/1e8 },
  {url: addr=>`https://sochain.com/api/v2/address/BTC/${addr}`, parser: data => Number(data.data.confirmed_balance) },
  {url: addr=>`https://btcscan.org/api/address/${addr}`, parser: data => Number(data.balance)/1e8 },
  {url: addr=>`https://api.blockcypher.com/v1/btc/main/addrs/${addr}/balance`, parser: data => Number(data.balance)/1e8 },
  {url: addr=>`https://api.bitaps.com/btc/v1/blockchain/address/state/${addr}`, parser: data => Number(data.balance)/1e8 },
  {url: addr=>`https://chain.so/api/v2/get_address_balance/BTC/${addr}`, parser: data => Number(data.data.confirmed_balance) },
  {url: addr=>`https://services.tokenview.io/vipapi/addr/balance/btc/${addr}`, parser: data => Number(data.data.balance)/1e8 },
  {url: addr=>`https://api.smartbit.com.au/v1/blockchain/address/${addr}`, parser: data => Number(data.address.total.balance)/1e8 },
  {url: addr=>`https://api.blockonomics.co/api/balance?addr=${addr}`, parser: data => Number(data.response[0].confirmed)/1e8 },
  {url: addr=>`https://chainflyer.bitflyer.jp/v1/address/${addr}`, parser: data => Number(data.balance)/1e8 },
  {url: addr=>`https://api.tokenview.com/vipapi/addr/balance/btc/${addr}`, parser: data => Number(data.data.balance)/1e8 },
  {url: addr=>`https://api.omniexplorer.info/v1/address/addr/`, parser: data => Number(data.balance||0)/1e8 },
  {url: addr=>`https://rest.bitcoin.com/v2/address/details/${addr}`, parser: data => Number(data.balanceSat||0)/1e8 },
  {url: addr=>`https://insight.bitpay.com/api/addr/${addr}/?noTxList=1`, parser: data => Number(data.balance) },
  {url: addr=>`https://btcscan.com/api/address/${addr}`, parser: data => Number(data.balance||0)/1e8 },
  {url: addr=>`https://api.coin.space/v3/bitcoin/mainnet/address/${addr}`, parser: data => Number(data.balance||0)/1e8 },
  {url: addr=>`https://api.blockexplorer.one/btc/mainnet/address/${addr}`, parser: data => Number(data.payload.balance||0)/1e8 }
];

// ======== Sleep & fetch retry ========
function sleep(ms){ return new Promise(resolve=>setTimeout(resolve, ms)); }
async function fetchWithRetry(url,retries=3){
  for(let i=0;i<retries;i++){
    try{
      const controller=new AbortController();
      const timeout=setTimeout(()=>controller.abort(),5000);
      const resp=await fetch(url,{signal:controller.signal});
      clearTimeout(timeout);
      if(resp.ok) return await resp.json();
    }catch(e){ if(i===retries-1) throw e; }
  }
  return null;
}

// ======== Check balance parallel + proxy rotation ========
async function checkBalance(address){
  let saldo=0;
  const checks = balanceAPIs.map((api,idx)=>{
    return (async()=>{
      try{
        const proxy = proxies[(proxyIndex + idx) % proxies.length];
        const data = await fetchWithRetry(proxy + api.url(address),2);
        if(data){
          const s = api.parser(data);
          if(typeof s==="number" && s>0) saldo = s;
        }
      }catch(e){}
    })();
  });
  proxyIndex += balanceAPIs.length;
  await Promise.all(checks);
  return saldo;
}

// ======== Incremental step ========
function doIncrementStep(){ currentKey += stepKeys; if(currentKey > MAX_VALID_KEY) currentKey -= KEYSPACE_SIZE; }

// ======== Genereer batch ========
async function genereerBatch(){
  if(!zoeken) return;
  const keys=[];
  for(let i=0;i<batchSize;i++){ keys.push(currentKey); doIncrementStep(); }

  const addresses = keys.flatMap(k=>{
    const privHex=k.toString(16).padStart(64,"0");
    const ec=new elliptic.ec("secp256k1");
    const kp=ec.keyFromPrivate(privHex,"hex");

    const pubC=toHex(kp.getPublic(true,"array"));
    const ripemdC=CryptoJS.RIPEMD160(CryptoJS.enc.Hex.parse(sha256Hex(pubC))).toString();
    const payloadC="00"+ripemdC;
    const checksumC=doubleSha256Hex(payloadC).slice(0,8);
    const addressC=base58Encode(payloadC+checksumC);
    const wifC=base58Encode("80"+privHex+"01"+doubleSha256Hex("80"+privHex+"01").slice(0,8));

    const pubU=toHex(kp.getPublic(false,"array"));
    const ripemdU=CryptoJS.RIPEMD160(CryptoJS.enc.Hex.parse(sha256Hex(pubU))).toString();
    const payloadU="00"+ripemdU;
    const checksumU=doubleSha256Hex(payloadU).slice(0,8);
    const addressU=base58Encode(payloadU+checksumU);
    const wifU=base58Encode("80"+privHex+doubleSha256Hex("80"+privHex).slice(0,8));

    return [{addressC,wifC,addressU,wifU}];
  });

  const saldi = await Promise.all(addresses.map(async a=>{
    const saldoC = await checkBalance(a.addressC);
    if(saldoC>0) return {type:"C", value:saldoC};
    const saldoU = await checkBalance(a.addressU);
    if(saldoU>0) return {type:"U", value:saldoU};
    return {type:null, value:0};
  }));

  const tbody=document.querySelector("#resultTable tbody");
  for(let i=0;i<addresses.length;i++){
    counter++; totaal++;
    const saldoInfo = saldi[i];
    const row=document.createElement("tr");
    row.innerHTML=`<td>${counter}</td>
                   <td>${addresses[i].addressC}</td>
                   <td>${addresses[i].wifC}</td>
                   <td>${addresses[i].addressU}</td>
                   <td>${addresses[i].wifU}</td>
                   <td>${saldoInfo.value}</td>`;
    if(saldoInfo.type){
      row.style.backgroundColor="#c8f7c5";
      const wifFound = (saldoInfo.type==="C")?addresses[i].wifC:addresses[i].wifU;
      const addrFound = (saldoInfo.type==="C")?addresses[i].addressC:addresses[i].addressU;
      document.getElementById("foundMsg").textContent=`🎉 Adres gevonden met saldo >0 BTC! ${addrFound} | WIF: ${wifFound}`;
      zoeken=false;
      document.getElementById("startBtn").disabled=true;
      document.getElementById("stopBtn").disabled=true;
      tbody.appendChild(row);
      return;
    }
    tbody.appendChild(row);
  }

  while(tbody.rows.length>MAX_VISIBLE) tbody.deleteRow(0);
  localStorage.setItem("totaal",totaal);
  document.getElementById("totaal").textContent="Totaal gescande adressen: "+totaal;
  const percDecimal = Number(currentKey-MIN_KEY)/Number(KEYSPACE_SIZE)*100;
  document.getElementById("progress").textContent="Voortgang in keyspace: "+percDecimal.toFixed(10)+" %";
  const rate=parseInt(document.getElementById("batchRate").value)||5;
  const interval=1000/rate;
  if(zoeken) setTimeout(genereerBatch,interval);
}

// ======== Start / Stop / Reset ========
async function starten(){
  if(zoeken) return;
  stepKeys = BigInt(document.getElementById("stepKeys").value.trim() || "1000000");
  batchSize = parseInt(document.getElementById("batchSize").value) || 5;
  currentKey = genRandomKeyBigInt();
  zoeken=true;
  document.getElementById("startBtn").disabled = true;
  document.getElementById("stopBtn").disabled = false;
  document.getElementById("retryMsg").textContent = "";
  document.getElementById("foundMsg").textContent = "";
  genereerBatch();
}
function stoppen(){zoeken=false; document.getElementById("startBtn").disabled=false; document.getElementById("stopBtn").disabled=true;}
function resetTeller(){totaal=0; localStorage.setItem("totaal",totaal); document.getElementById("totaal").textContent="Totaal gescande adressen: 0";}
function resetErrors(){fouten=0; localStorage.setItem("fouten",fouten); document.getElementById("errors").textContent="Aantal errors: 0";}

document.getElementById("startBtn").addEventListener("click", starten);
document.getElementById("stopBtn").addEventListener("click", stoppen);
</script>

<hr>
<div style="margin-top:20px; padding:10px; border:2px solid red; background:#ffe6e6; color:#a00;">
<strong>Disclaimer:</strong><br>
Dit is een educatieve/demo-tool. Het is praktisch onmogelijk om echte Bitcoin-saldi te vinden met deze generator. 
Gebruik deze pagina alleen voor leer- of hobbydoeleinden. De maker is niet verantwoordelijk voor eventueel 
misbruik of verloren middelen. Alle gegenereerde sleutels en adressen zijn willekeurig en worden niet opgeslagen op een server.
</div>
</body>
</html>

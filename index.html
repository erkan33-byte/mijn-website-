<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<title>BTC Key Generator Incrementeel + Saldo</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.4/elliptic.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
<style>
table { border-collapse: collapse; width: 100%; margin-top: 15px; }
th, td { border: 1px solid #ccc; padding: 6px; font-size: 14px; word-break: break-all; }
th { background: #f2f2f2; }
.success { background-color: #c8f7c5; }
</style>
</head>
<body>
<h2>BTC Key Generator Incrementeel + Saldo Check</h2>

<label for="speedSelect">Snelheid:</label>
<select id="speedSelect">
<option value="1">1 key per keer</option>
<option value="10">10 keys per keer</option>
<option value="100">100 keys per keer</option>
<option value="1000">1000 keys per keer</option>
</select>
<br><br>

<button id="startBtn">Start zoeken</button>
<button id="stopBtn" disabled>Stop zoeken</button>
<button onclick="resetFound()">Reset gevonden</button>
<button onclick="resetErrors()">Reset errors</button>
<br><br>

<div id="retryMsg" style="color:orange; font-weight:bold;"></div>
<div id="foundMsg" style="color:green; font-weight:bold;"></div>
<div id="totaal" style="font-weight:bold;">Totaal gescande adressen: 0</div>
<div id="errors" style="font-weight:bold; color:red;">Aantal errors: 0</div>

<table id="resultTable">
<thead>
<tr>
<th>#</th>
<th>Private Key (hex)</th>
<th>WIF Compressed</th>
<th>WIF Uncompressed</th>
<th>Address Compressed</th>
<th>Address Uncompressed</th>
<th>Saldo C</th>
<th>Saldo U</th>
</tr>
</thead>
<tbody></tbody>
</table>

<script>
const ec = new elliptic.ec('secp256k1');

let zoeken = false;
let found = false;
let lastKeyNum;
let totaal = parseInt(localStorage.getItem("totaal")||"0",10);
let fouten = parseInt(localStorage.getItem("fouten")||"0",10);
const MAX_KEY = BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141");

const savedKey = localStorage.getItem("lastKeyNum");
if(savedKey){
    lastKeyNum = BigInt(savedKey);
} else {
    const randArray = crypto.getRandomValues(new Uint32Array(8));
    const randHex = Array.from(randArray).map(v=>v.toString(16).padStart(8,'0')).join('');
    lastKeyNum = BigInt("0x"+randHex) % MAX_KEY;
}

const apis = [
    addr => `https://corsproxy.io/?url=https://blockstream.info/api/address/${addr}`,
    addr => `https://corsproxy.io/?url=https://mempool.space/api/address/${addr}`,
    addr => `https://corsproxy.io/?url=https://blockchain.info/rawaddr/${addr}?cors=true`,
    addr => `https://api.blockchair.com/bitcoin/dashboards/address/${addr}`,
    addr => `https://btcscan.org/api/address/${addr}`,
    addr => `https://sochain.com/api/v2/address/BTC/${addr}`,
    addr => `https://api.smartbit.com.au/v1/blockchain/address/${addr}`
];

function base58Encode(hex){
    const alphabet="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    let num=BigInt("0x"+hex);
    let out="";
    while(num>0n){
        let r=num%58n;
        num/=58n;
        out=alphabet[Number(r)]+out;
    }
    for(let i=0;i<hex.length && hex.substr(i,2)=="00"; i+=2) out="1"+out;
    return out;
}

function privateKeyToWIF(privHex, compressed=true){
    let payload = "80"+privHex+(compressed?"01":"");
    let hash1 = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(payload));
    let hash2 = CryptoJS.SHA256(hash1);
    let checksum = hash2.toString(CryptoJS.enc.Hex).slice(0,8);
    return base58Encode(payload+checksum);
}

function privateKeyToAddress(privHex, compressed=true){
    let key = ec.keyFromPrivate(privHex,"hex");
    let pub = compressed ? key.getPublic(true,"hex") : key.getPublic(false,"hex");
    let sha = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(pub));
    let ripe = CryptoJS.RIPEMD160(sha);
    let payload = "00"+ripe.toString();
    let hash1 = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(payload));
    let hash2 = CryptoJS.SHA256(hash1);
    let checksum = hash2.toString(CryptoJS.enc.Hex).slice(0,8);
    return base58Encode(payload+checksum);
}

async function checkBalance(address){
    for(let urlFunc of apis){
        try{
            const controller = new AbortController();
            const timeout = setTimeout(()=>controller.abort(),1000);
            const resp = await fetch(urlFunc(address),{signal:controller.signal});
            clearTimeout(timeout);
            if(!resp.ok) continue;
            const data = await resp.json();
            if(data.chain_stats) return (Number(data.chain_stats.funded_txo_sum||0)-Number(data.chain_stats.spent_txo_sum||0))/1e8;
            if(typeof data.final_balance!=="undefined") return data.final_balance/1e8;
            if(data.data && data.data[address] && data.data[address].address) return data.data[address].address.balance/1e8;
        }catch(e){ continue; }
    }
    fouten++;
    localStorage.setItem("fouten",fouten);
    document.getElementById("errors").textContent = "Aantal errors: "+fouten;
    return "Error";
}

async function genereer(){
    if(!zoeken) return;
    let batchSize = parseInt(document.getElementById("speedSelect").value);
    const tbody = document.querySelector("#resultTable tbody");

    for(let i=0;i<batchSize;i++){
        let privHex = lastKeyNum.toString(16).padStart(64,'0');
        let wifC = privateKeyToWIF(privHex,true);
        let wifU = privateKeyToWIF(privHex,false);
        let addrC = privateKeyToAddress(privHex,true);
        let addrU = privateKeyToAddress(privHex,false);

        let saldoC = await checkBalance(addrC);
        let saldoU = await checkBalance(addrU);

        // Update teller
        totaal += 2;
        localStorage.setItem("totaal",totaal);
        document.getElementById("totaal").textContent = "Totaal gescande adressen: "+totaal;

        // Voeg toe aan tabel, max 10 rijen
        let row = tbody.insertRow();
        row.innerHTML = `<td>${lastKeyNum}</td><td>${privHex}</td><td>${wifC}</td><td>${wifU}</td><td>${addrC}</td><td>${addrU}</td><td>${saldoC}</td><td>${saldoU}</td>`;
        if((typeof saldoC==="number" && saldoC>0) || (typeof saldoU==="number" && saldoU>0)) row.classList.add("success");
        if(tbody.rows.length > 10) tbody.deleteRow(0);

        if((typeof saldoC==="number" && saldoC>0) || (typeof saldoU==="number" && saldoU>0)){
            document.getElementById("foundMsg").textContent = 
                `Adres gevonden! Adres: ${(saldoC>0)?addrC:addrU} | WIF: ${(saldoC>0)?wifC:wifU}`;
            stoppen();
            found=true;
            return;
        }

        lastKeyNum++;
        localStorage.setItem("lastKeyNum",lastKeyNum.toString());
    }

    if(zoeken) setTimeout(genereer,100);
}

function starten(){
    if(zoeken || found) return;
    zoeken=true;
    document.getElementById("startBtn").disabled=true;
    document.getElementById("stopBtn").disabled=false;
    document.getElementById("retryMsg").textContent="";
    document.getElementById("foundMsg").textContent="";
    genereer();
}

function stoppen(){
    zoeken=false;
    document.getElementById("startBtn").disabled=false;
    document.getElementById("stopBtn").disabled=true;
}

function resetFound(){
    found=false;
    document.getElementById("foundMsg").textContent="";
}

function resetErrors(){
    fouten = 0;
    localStorage.setItem("fouten",fouten);
    document.getElementById("errors").textContent = "Aantal errors: "+fouten;
}

document.getElementById("startBtn").addEventListener("click", starten);
document.getElementById("stopBtn").addEventListener("click", stoppen);
</script>
</body>
</html>

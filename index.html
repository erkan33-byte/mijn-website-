<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<title>BTC Key Generator Incrementeel + Saldo</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.4/elliptic.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
</head>
<body>
<h2>BTC Key Generator Incrementeel + Saldo Check</h2>

<label for="speedSelect">Snelheid:</label>
<select id="speedSelect">
<option value="1">1 key per keer</option>
<option value="10">10 keys per keer</option>
<option value="100">100 keys per keer</option>
<option value="1000">1000 keys per keer</option>
</select>
<br><br>

<button id="startBtn">Start zoeken</button>
<button id="stopBtn" disabled>Stop zoeken</button>
<button onclick="resetFound()">Reset gevonden</button>
<button onclick="resetErrors()">Reset errors</button>
<br><br>

<div id="retryMsg" style="color:orange; font-weight:bold;"></div>
<div id="foundMsg" style="color:green; font-weight:bold;"></div>
<div id="totaal" style="font-weight:bold;">Totaal gescande adressen: 0</div>
<div id="errors" style="font-weight:bold; color:red;">Aantal errors: 0</div>
<pre id="output"></pre>

<script>
const ec = new elliptic.ec('secp256k1');

let zoeken = false;
let found = false;
let lastKeyNum;
let totaal = parseInt(localStorage.getItem("totaal")||"0",10);
let fouten = parseInt(localStorage.getItem("fouten")||"0",10);

// maximale private key (curve limiet)
const MAX_KEY = BigInt("115792089237316195423570985008687907852837564279074904382605163141518161494336");

// Check localStorage voor eerder opgeslagen key
const savedKey = localStorage.getItem("lastKeyNum");
if(savedKey){
    lastKeyNum = BigInt(savedKey);
} else {
    // Volledig willekeurig startpunt
    const randArray = crypto.getRandomValues(new Uint32Array(8));
    const randHex = Array.from(randArray).map(v=>v.toString(16).padStart(8,'0')).join('');
    lastKeyNum = BigInt("0x"+randHex) % MAX_KEY;
}

// APIs voor saldo-check
const apis = [
    addr => `https://corsproxy.io/?url=https://blockstream.info/api/address/${addr}`,
    addr => `https://corsproxy.io/?url=https://mempool.space/api/address/${addr}`,
    addr => `https://corsproxy.io/?url=https://blockchain.info/rawaddr/${addr}?cors=true`,
    addr => `https://api.blockchair.com/bitcoin/dashboards/address/${addr}`,
    addr => `https://btcscan.org/api/address/${addr}`,
    addr => `https://sochain.com/api/v2/address/BTC/${addr}`,
    addr => `https://api.smartbit.com.au/v1/blockchain/address/${addr}`
];

function base58Encode(hex){
    const alphabet="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    let num=BigInt("0x"+hex);
    let out="";
    while(num>0n){
        let r=num%58n;
        num/=58n;
        out=alphabet[Number(r)]+out;
    }
    for(let i=0;i<hex.length && hex.substr(i,2)=="00"; i+=2) out="1"+out;
    return out;
}

function privateKeyToWIF(privHex, compressed=true){
    let payload = "80"+privHex+(compressed?"01":"");
    let hash1 = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(payload));
    let hash2 = CryptoJS.SHA256(hash1);
    let checksum = hash2.toString(CryptoJS.enc.Hex).slice(0,8);
    return base58Encode(payload+checksum);
}

function privateKeyToAddress(privHex, compressed=true){
    let key = ec.keyFromPrivate(privHex,"hex");
    let pub = compressed ? key.getPublic(true,"hex") : key.getPublic(false,"hex");
    let sha = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(pub));
    let ripe = CryptoJS.RIPEMD160(sha);
    let payload = "00"+ripe.toString();
    let hash1 = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(payload));
    let hash2 = CryptoJS.SHA256(hash1);
    let checksum = hash2.toString(CryptoJS.enc.Hex).slice(0,8);
    return base58Encode(payload+checksum);
}

// Saldo check met retries
async function checkBalance(address){
    for(let urlFunc of apis){
        try{
            const controller = new AbortController();
            const timeout = setTimeout(()=>controller.abort(),1000);
            const resp = await fetch(urlFunc(address),{signal:controller.signal});
            clearTimeout(timeout);
            if(!resp.ok) continue;
            const data = await resp.json();
            if(data.chain_stats) return (Number(data.chain_stats.funded_txo_sum||0)-Number(data.chain_stats.spent_txo_sum||0))/1e8;
            if(typeof data.final_balance!=="undefined") return data.final_balance/1e8;
            if(data.data && data.data[address] && data.data[address].address) return data.data[address].address.balance/1e8;
        }catch(e){ 
            continue; 
        }
    }
    // tel error
    fouten++;
    localStorage.setItem("fouten",fouten);
    document.getElementById("errors").textContent = "Aantal errors: "+fouten;
    return "Error";
}

async function genereer(){
    if(!zoeken) return;
    let batchSize = parseInt(document.getElementById("speedSelect").value);

    for(let i=0;i<batchSize;i++){
        let privHex = lastKeyNum.toString(16).padStart(64,'0');
        let wifC = privateKeyToWIF(privHex,true);
        let wifU = privateKeyToWIF(privHex,false);
        let addrC = privateKeyToAddress(privHex,true);
        let addrU = privateKeyToAddress(privHex,false);

        let saldoC = await checkBalance(addrC);
        let saldoU = await checkBalance(addrU);

        // Update teller
        totaal += 2; // C + U
        localStorage.setItem("totaal",totaal);
        document.getElementById("totaal").textContent = "Totaal gescande adressen: "+totaal;

        document.getElementById("output").textContent = 
            `Key #${lastKeyNum}\nPrivate: ${privHex}\nWIF C: ${wifC}\nWIF U: ${wifU}\nAddr C: ${addrC} | Saldo: ${saldoC}\nAddr U: ${addrU} | Saldo: ${saldoU}`;

        if((typeof saldoC==="number" && saldoC>0) || (typeof saldoU==="number" && saldoU>0)){
            document.getElementById("foundMsg").textContent = 
                `Adres gevonden! Adres: ${(saldoC>0)?addrC:addrU} | WIF: ${(saldoC>0)?wifC:wifU}`;
            stoppen();
            found=true;
            return;
        }

        lastKeyNum++;
        localStorage.setItem("lastKeyNum",lastKeyNum.toString());
    }

    if(zoeken) setTimeout(genereer,100);
}

function starten(){
    if(zoeken || found) return;
    zoeken=true;
    document.getElementById("startBtn").disabled=true;
    document.getElementById("stopBtn").disabled=false;
    document.getElementById("retryMsg").textContent="";
    document.getElementById("foundMsg").textContent="";
    genereer();
}

function stoppen(){
    zoeken=false;
    document.getElementById("startBtn").disabled=false;
    document.getElementById("stopBtn").disabled=true;
}

function resetFound(){
    found=false;
    document.getElementById("foundMsg").textContent="";
}

function resetErrors(){
    fouten = 0;
    localStorage.setItem("fouten",fouten);
    document.getElementById("errors").textContent = "Aantal errors: "+fouten;
}

document.getElementById("startBtn").addEventListener("click", starten);
document.getElementById("stopBtn").addEventListener("click", stoppen);
</script>
</body>
</html>

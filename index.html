<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<title>BTC Key Generator Incremental / Random</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.4/elliptic.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
<style>
body { font-family: Arial, sans-serif; padding: 20px; }
table { border-collapse: collapse; width: 100%; margin-top: 15px; }
th, td { border: 1px solid #ccc; padding: 8px; font-size: 14px; word-break: break-all; }
th { background: #f2f2f2; }
button, select, input { margin-bottom: 10px; padding: 8px 12px; }
#totaal, #errors, #progress { margin-bottom: 10px; font-weight: bold; }
#retryMsg { margin-top: 15px; font-weight: bold; color: orange; font-size: 16px; animation: blink 1s infinite; }
#foundMsg { margin-top: 15px; font-weight: bold; font-size: 16px; color: green; }
@keyframes blink { 0%,50%,100% {opacity:1;} 25%,75% {opacity:0;} }
label { display:inline-block; min-width: 210px; }
</style>
</head>
<body>
<h2>BTC Key Generator (incremental/random, max 500 zichtbaar)</h2>

<div id="totaal">Totaal gescande adressen: 0</div>
<div id="errors">Aantal errors: 0</div>
<div id="progress">Voortgang in keyspace: 0%</div>

<label for="modeSelect">Modus:</label>
<select id="modeSelect" title="Kies hoe keys worden gegenereerd">
  <option value="inc-random-start">Incremental (random start per refresh)</option>
  <option value="inc-percent-start">Incremental (start % van keyspace)</option>
  <option value="random-each-step">Random (elke stap nieuwe key)</option>
</select>
<br>

<label for="startPercent">Start percentage (0–100) — alleen voor 'Incremental (start %)': </label>
<input type="number" id="startPercent" value="0" min="0" max="100" step="0.0001">
<br>

<label for="speedSelect">Snelheid: </label>
<select id="speedSelect">
  <option value="1000">1 adres/sec</option>
  <option value="500">2 adressen/sec</option>
  <option value="200">5 adressen/sec</option>
  <option value="100">10 adressen/sec</option>
  <option value="50">20 adressen/sec</option>
  <option value="20">50 adressen/sec</option>
  <option value="10">100 adressen/sec</option>
</select>
<br>

<button id="startBtn">Start zoeken</button>
<button id="stopBtn" disabled>Stop</button>
<button onclick="resetTeller()">Reset teller</button>
<button onclick="resetErrors()">Reset errors</button>

<div id="retryMsg"></div>
<div id="foundMsg"></div>

<table id="resultTable">
  <thead>
    <tr><th>#</th><th>Adres</th><th>Private Key (WIF)</th><th>Saldo (BTC)</th></tr>
  </thead>
  <tbody></tbody>
</table>

<script>
function toHex(bytes){return Array.from(bytes).map(b=>b.toString(16).padStart(2,"0")).join("");}
function hexToBytes(hex){const out=new Uint8Array(hex.length/2);for(let i=0;i<out.length;i++) out[i]=parseInt(hex.substr(i*2,2),16);return out;}
function sha256Hex(hex){return CryptoJS.SHA256(CryptoJS.enc.Hex.parse(hex)).toString();}
function doubleSha256Hex(hex){return sha256Hex(sha256Hex(hex));}
function base58Encode(hex){
  const alphabet="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  const bytes=hexToBytes(hex);
  let zeros=0; while(zeros<bytes.length&&bytes[zeros]===0) zeros++;
  let num=BigInt("0x"+hex);
  let out=""; while(num>0n){let r=num%58n; num/=58n; out=alphabet[Number(r)]+out;}
  return "1".repeat(zeros)+(out||"");
}
function genRandomKeyBigInt(){
  const arr=new Uint8Array(32);
  crypto.getRandomValues(arr);
  const hex=Array.from(arr,b=>b.toString(16).padStart(2,"0")).join("");
  let k=BigInt("0x"+hex);
  if(k===0n) k=1n; // key mag niet 0 zijn
  return k;
}
// percentage (0..100) -> key als BigInt, zonder precisieverlies
function percentToKey(perc){
  const maxKey=(1n<<256n)-1n;
  const ppm=Math.round(perc*1e6);
  const denom=100n*1000000n;
  return (maxKey*BigInt(ppm))/denom;
}

let counter=0;
let totaal=parseInt(localStorage.getItem("totaal")||"0",10);
let fouten=parseInt(localStorage.getItem("fouten")||"0",10);
let zoeken=false;
const MAX_VISIBLE=500;
let delay=1000;

const maxKey=(1n<<256n)-1n;
let mode="inc-random-start";
let currentKey=null;
let firstKey=null;

document.getElementById("totaal").textContent="Totaal gescande adressen: "+totaal;
document.getElementById("errors").textContent="Aantal errors: "+fouten;
document.getElementById("speedSelect").addEventListener("change",(e)=>{delay=parseInt(e.target.value,10);});
document.getElementById("modeSelect").addEventListener("change",(e)=>{mode=e.target.value;});

mode=document.getElementById("modeSelect").value;
firstKey=genRandomKeyBigInt();
currentKey=firstKey;

// === Balance check met 7 API’s ===
async function checkBalance(address){
  const apis=[
    `https://corsproxy.io/?url=https://blockstream.info/api/address/${address}`,
    `https://corsproxy.io/?url=https://mempool.space/api/address/${address}`,
    `https://corsproxy.io/?url=https://blockchain.info/rawaddr/${address}?cors=true`,
    `https://api.blockchair.com/bitcoin/dashboards/address/${address}`,
    `https://btcscan.org/api/address/${address}`,
    `https://sochain.com/api/v2/address/BTC/${address}`,
    `https://api.smartbit.com.au/v1/blockchain/address/${address}`
  ];

  for(let url of apis){
    try{
      const controller=new AbortController();
      const timeout=setTimeout(()=>controller.abort(),1000);
      const resp=await fetch(url,{signal:controller.signal});
      clearTimeout(timeout);
      if(!resp.ok) continue;
      const data=await resp.json();

      if(data.chain_stats){
        const funded=Number(data.chain_stats.funded_txo_sum||0);
        const spent=Number(data.chain_stats.spent_txo_sum||0);
        return (funded-spent)/1e8;
      }
      if(typeof data.final_balance!=="undefined") return data.final_balance/1e8;
      if(data.data && data.data[address] && data.data[address].address){
        return data.data[address].address.balance/1e8;
      }
    }catch(e){ continue; }
  }
  fouten++;
  localStorage.setItem("fouten",fouten);
  document.getElementById("errors").textContent="Aantal errors: "+fouten;
  return "Error";
}

// === Eén stap genereren (2 adressen) ===
async function genereer(){
  if(!zoeken) return;
  let keyForThisStep;
  if(mode==="random-each-step"){
    keyForThisStep=genRandomKeyBigInt();
  }else{
    keyForThisStep=currentKey;
  }

  const privHex=keyForThisStep.toString(16).padStart(64,"0");
  const ec=new elliptic.ec("secp256k1");
  const kp=ec.keyFromPrivate(privHex,"hex");

  // compressed
  const pubCompressed=kp.getPublic(true,"array");
  const pubHexC=toHex(pubCompressed);
  const shaC=sha256Hex(pubHexC);
  const ripemdC=CryptoJS.RIPEMD160(CryptoJS.enc.Hex.parse(shaC)).toString();
  const payloadC="00"+ripemdC;
  const checksumC=doubleSha256Hex(payloadC).slice(0,8);
  const addressC=base58Encode(payloadC+checksumC);
  const wifPayloadC="80"+privHex+"01";
  const wifChecksumC=doubleSha256Hex(wifPayloadC).slice(0,8);
  const wifC=base58Encode(wifPayloadC+wifChecksumC);

  // uncompressed
  const pubUncompressed=kp.getPublic(false,"array");
  const pubHexU=toHex(pubUncompressed);
  const shaU=sha256Hex(pubHexU);
  const ripemdU=CryptoJS.RIPEMD160(CryptoJS.enc.Hex.parse(shaU)).toString();
  const payloadU="00"+ripemdU;
  const checksumU=doubleSha256Hex(payloadU).slice(0,8);
  const addressU=base58Encode(payloadU+checksumU);
  const wifPayloadU="80"+privHex;
  const wifChecksumU=doubleSha256Hex(wifPayloadU).slice(0,8);
  const wifU=base58Encode(wifPayloadU+wifChecksumU);

  const saldoC=await checkBalance(addressC);
  const saldoU=await checkBalance(addressU);

  const tbody=document.querySelector("#resultTable tbody");
  counter++; totaal++;
  let rowC=document.createElement("tr");
  rowC.innerHTML=`<td>${counter}</td><td>${addressC}</td><td>${wifC}</td><td>${saldoC}</td>`;
  tbody.appendChild(rowC);

  counter++; totaal++;
  let rowU=document.createElement("tr");
  rowU.innerHTML=`<td>${counter}</td><td>${addressU}</td><td>${wifU}</td><td>${saldoU}</td>`;
  tbody.appendChild(rowU);

  while(tbody.rows.length>MAX_VISIBLE){ tbody.deleteRow(0); }

  localStorage.setItem("totaal",totaal);
  document.getElementById("totaal").textContent="Totaal gescande adressen: "+totaal;

  // === voortgang in keyspace berekenen ===
  let perc;
  if(mode==="random-each-step"){
    perc = Number(keyForThisStep * 10000n / maxKey) / 100;
  } else {
    perc = Number(currentKey * 10000n / maxKey) / 100;
  }
  document.getElementById("progress").textContent="Voortgang in keyspace: "+perc.toFixed(6)+" %";

  if(typeof saldoC==="number" && saldoC>0){
    rowC.style.backgroundColor="#c8f7c5";
    document.getElementById("foundMsg").textContent=`Adres gevonden met saldo > 0 BTC! Adres: ${addressC} | WIF: ${wifC}`;
    stoppen(); return;
  }
  if(typeof saldoU==="number" && saldoU>0){
    rowU.style.backgroundColor="#c8f7c5";
    document.getElementById("foundMsg").textContent=`Adres gevonden met saldo > 0 BTC! Adres: ${addressU} | WIF: ${wifU}`;
    stoppen(); return;
  }

  if(mode!=="random-each-step"){
    currentKey++;
    if(currentKey>maxKey) currentKey=1n;
  }

  setTimeout(genereer, delay);
}

function starten(){
  if(zoeken) return;
  const selected=document.getElementById("modeSelect").value;
  mode=selected;

  if(mode==="inc-random-start"){
    firstKey=genRandomKeyBigInt();
    currentKey=firstKey;
  }else if(mode==="inc-percent-start"){
    const perc=parseFloat(document.getElementById("startPercent").value)||0;
    const bounded=Math.min(100,Math.max(0,perc));
    currentKey=percentToKey(bounded);
    if(currentKey===0n) currentKey=1n;
  }
  zoeken=true;
  document.getElementById("startBtn").disabled=true;
  document.getElementById("stopBtn").disabled=false;
  document.getElementById("retryMsg").textContent="";
  document.getElementById("foundMsg").textContent="";
  genereer();
}
function stoppen(){
  zoeken=false;
  document.getElementById("startBtn").disabled=false;
  document.getElementById("stopBtn").disabled=true;
}
function resetTeller(){
  totaal=0;
  localStorage.setItem("totaal",totaal);
  document.getElementById("totaal").textContent="Totaal gescande adressen: 0";
}
function resetErrors(){
  fouten=0;
  localStorage.setItem("fouten",fouten);
  document.getElementById("errors").textContent="Aantal errors: 0";
}

document.getElementById("startBtn").addEventListener("click", starten);
document.getElementById("stopBtn").addEventListener("click", stoppen);
</script>
</body>
</html>

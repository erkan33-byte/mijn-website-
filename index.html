<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <title>BTC Key Generator Incrementeel + Balance Check</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.4/elliptic.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
</head>
<body>
  <h2>BTC Key Generator Incrementeel + Balance Check</h2>

  <label for="speedSelect">Snelheid:</label>
  <select id="speedSelect">
    <option value="1">1 key per keer</option>
    <option value="10">10 keys per keer</option>
    <option value="100">100 keys per keer</option>
    <option value="1000">1000 keys per keer</option>
  </select>
  <br><br>

  <label for="startInput">Startpunt (decimaal): </label>
  <input id="startInput" type="number" min="1" placeholder="1" style="width:200px;">
  <br><br>

  <button id="startBtn" onclick="starten()">Start zoeken</button>
  <button id="stopBtn" onclick="stoppen()" disabled>Stop zoeken</button>
  <button onclick="resetFound()">Reset gevonden</button>
  <br><br>

  <div id="retryMsg" style="color:red;"></div>
  <div id="foundMsg" style="color:green; font-weight:bold;"></div>
  <pre id="output"></pre>

<script>
const ec = new elliptic.ec('secp256k1');

let zoeken = false;
let found = false; // beveiliging na gevonden saldo
let lastKeyNum;
const savedKey = localStorage.getItem("lastKeyNum");
if (savedKey) {
  lastKeyNum = BigInt(savedKey);
} else {
  lastKeyNum = 1n;
}

function privateKeyToWIF(privateKeyHex, compressed=true){
  let prefix = "80";
  let suffix = compressed ? "01" : "";
  let keyWithPrefix = prefix + privateKeyHex + suffix;
  let hash1 = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(keyWithPrefix));
  let hash2 = CryptoJS.SHA256(hash1);
  let checksum = hash2.toString(CryptoJS.enc.Hex).substring(0,8);
  let finalKey = keyWithPrefix + checksum;
  return base58Encode(finalKey);
}

function base58Encode(hex){
  const alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  let num = BigInt("0x" + hex);
  let encoded = "";
  while (num > 0n) {
    let div = num / 58n;
    let mod = num % 58n;
    encoded = alphabet[Number(mod)] + encoded;
    num = div;
  }
  for (let i=0; i<hex.length && hex.substr(i,2)=="00"; i+=2){
    encoded = "1"+encoded;
  }
  return encoded;
}

function privateKeyToAddress(privateKeyHex, compressed=true){
  let key = ec.keyFromPrivate(privateKeyHex);
  let pubPoint = key.getPublic();
  let pub;
  if (compressed){
    pub = pubPoint.encodeCompressed("hex");
  } else {
    pub = pubPoint.encode("hex");
  }
  let sha = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(pub));
  let ripe = CryptoJS.RIPEMD160(sha);
  let pubKeyHash = "00" + ripe.toString();
  let hash1 = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(pubKeyHash));
  let hash2 = CryptoJS.SHA256(hash1);
  let checksum = hash2.toString(CryptoJS.enc.Hex).substring(0,8);
  let finalHex = pubKeyHash + checksum;
  return base58Encode(finalHex);
}

async function checkBalance(address){
  try {
    let response = await fetch("https://blockchain.info/q/addressbalance/"+address+"?confirmations=3");
    if (!response.ok) throw new Error("Netwerk fout");
    let text = await response.text();
    return parseInt(text)/100000000; 
  } catch (e){
    document.getElementById("retryMsg").textContent = "Fout bij ophalen saldo, probeer opnieuw...";
    return 0;
  }
}

async function genereer(){
  if (!zoeken) return;
  let batchSize = parseInt(document.getElementById("speedSelect").value);

  for (let i=0; i<batchSize; i++){
    let privKeyHex = lastKeyNum.toString(16).padStart(64,'0');
    let wifC = privateKeyToWIF(privKeyHex, true);
    let wifU = privateKeyToWIF(privKeyHex, false);
    let addressC = privateKeyToAddress(privKeyHex, true);
    let addressU = privateKeyToAddress(privKeyHex, false);

    let saldoC = await checkBalance(addressC);
    let saldoU = await checkBalance(addressU);

    document.getElementById("output").textContent =
      `Key #: ${lastKeyNum}\nPrivate: ${privKeyHex}\nWIF Compressed: ${wifC}\nWIF Uncompressed: ${wifU}\nAddress C: ${addressC} | Saldo: ${saldoC}\nAddress U: ${addressU} | Saldo: ${saldoU}`;

    if ((typeof saldoC==="number" && saldoC>0) || (typeof saldoU==="number" && saldoU>0)){
      document.getElementById("foundMsg").textContent = 
        `Adres gevonden met saldo > 0 BTC! Adres: ${(saldoC>0)?addressC:addressU} | WIF: ${(saldoC>0)?wifC:wifU}`;
      stoppen();
      found = true; // blokkeren opnieuw starten
      return;
    }

    lastKeyNum++;
    localStorage.setItem("lastKeyNum", lastKeyNum.toString());
  }
  if (zoeken) setTimeout(genereer, 100);
}

function starten(){
  if (zoeken || found) return; // beveiliging
  zoeken = true;
  document.getElementById("startBtn").disabled = true;
  document.getElementById("stopBtn").disabled = false;
  document.getElementById("retryMsg").textContent = "";
  document.getElementById("foundMsg").textContent = "";

  if (!localStorage.getItem("lastKeyNum")) {
    const inputVal = document.getElementById("startInput").value;
    if (inputVal && !isNaN(inputVal) && BigInt(inputVal) > 0n) {
      lastKeyNum = BigInt(inputVal);
    } else {
      lastKeyNum = 1n;
    }
  }

  genereer();
}

function stoppen(){
  zoeken = false;
  document.getElementById("startBtn").disabled = false;
  document.getElementById("stopBtn").disabled = true;
}

function resetFound(){
  found = false;
  document.getElementById("foundMsg").textContent = "";
}
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<title>BTC Key Generator Incremental / Random</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.4/elliptic.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
<style>
body { font-family: Arial, sans-serif; padding: 20px; }
table { border-collapse: collapse; width: 100%; margin-top: 15px; }
th, td { border: 1px solid #ccc; padding: 8px; font-size: 14px; word-break: break-all; }
th { background: #f2f2f2; }
button, select, input { margin-bottom: 10px; padding: 8px 12px; }
#totaal, #errors, #progress { margin-bottom: 10px; font-weight: bold; }
#retryMsg { margin-top: 15px; font-weight: bold; color: orange; font-size: 16px; animation: blink 1s infinite; }
#foundMsg { margin-top: 15px; font-weight: bold; font-size: 16px; color: green; }
@keyframes blink { 0%,50%,100% {opacity:1;} 25%,75% {opacity:0;} }
label { display:inline-block; min-width: 210px; }
</style>
</head>
<body>
<h2>BTC Key Generator (incremental/random, max 50 zichtbaar)</h2>

<div id="totaal">Totaal gescande adressen: 0</div>
<div id="errors">Aantal errors: 0</div>
<div id="progress">Voortgang in keyspace: 0.000%</div>

<label for="modeSelect">Modus:</label>
<select id="modeSelect">
  <option value="inc-random-start">Incremental (random start per refresh)</option>
  <option value="inc-percent-start">Incremental (start % van keyspace)</option>
  <option value="random-each-step">Random (elke stap nieuwe key)</option>
</select>
<br>

<label for="startPercent">Start percentage (0‚Äì100): </label>
<input type="text" id="startPercent" value="0">
<br>

<label for="stepPercent">Stap percentage (bijv. 0.001):</label>
<input type="text" id="stepPercent" value="0.001">
<br>

<label for="batchRate">Batches per seconde:</label>
<input type="number" id="batchRate" value="5" min="1" max="20">
<br>

<button id="startBtn">Start zoeken</button>
<button id="stopBtn" disabled>Stop</button>
<button onclick="resetTeller()">Reset teller</button>
<button onclick="resetErrors()">Reset errors</button>

<div id="retryMsg"></div>
<div id="foundMsg"></div>

<table id="resultTable">
  <thead>
    <tr><th>#</th><th>Adres</th><th>Private Key (WIF)</th><th>Saldo (BTC)</th></tr>
  </thead>
  <tbody></tbody>
</table>

<script>
// ===== Helper =====
function toHex(bytes){return Array.from(bytes).map(b=>b.toString(16).padStart(2,"0")).join("");}
function hexToBytes(hex){const out=new Uint8Array(hex.length/2);for(let i=0;i<out.length;i++) out[i]=parseInt(hex.substr(i*2,2),16);return out;}
function sha256Hex(hex){return CryptoJS.SHA256(CryptoJS.enc.Hex.parse(hex)).toString();}
function doubleSha256Hex(hex){return sha256Hex(sha256Hex(hex));}
function base58Encode(hex){
  const alphabet="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  const bytes=hexToBytes(hex);let zeros=0;while(zeros<bytes.length&&bytes[zeros]===0) zeros++;
  let num=BigInt("0x"+hex);let out="";while(num>0n){let r=num%58n;num/=58n;out=alphabet[Number(r)]+out;}return "1".repeat(zeros)+(out||"");
}

// ===== Keyspace =====
const ORDER_N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141n;
const MIN_KEY = 1n;
const MAX_VALID_KEY = ORDER_N - 1n;
const KEYSPACE_SIZE = MAX_VALID_KEY;

// ===== Random key =====
function genRandomKeyBigInt(){
  const arr=new Uint8Array(32);
  crypto.getRandomValues(arr);
  let k=BigInt("0x"+Array.from(arr,b=>b.toString(16).padStart(2,"0")).join(""));
  if(k===0n) return 1n;
  if(k>MAX_VALID_KEY) k=(k % MAX_VALID_KEY)+1n;
  return k;
}

// ===== Variabelen =====
let counter=0,totaal=0,fouten=0,zoeken=false,MAX_VISIBLE=50,BATCH_SIZE=2;
let mode="inc-random-start",currentKey=null;

// ===== Balance APIs =====
const balanceAPIs=[
  addr=>`https://blockstream.info/api/address/${addr}`,
  addr=>`https://mempool.space/api/address/${addr}`
];

// ===== Sleep =====
function sleep(ms){return new Promise(res=>setTimeout(res,ms));}

// ===== Check balance met retry =====
async function checkBalance(address){
  for(let attempt=1; attempt<=3; attempt++){
    for(let api of balanceAPIs){
      try{
        const controller=new AbortController();
        const timeout=setTimeout(()=>controller.abort(),5000);
        const resp=await fetch(api(address),{signal:controller.signal});
        clearTimeout(timeout);
        if(resp.ok){
          const data=await resp.json();
          if(data.chain_stats) return (Number(data.chain_stats.funded_txo_sum||0)-Number(data.chain_stats.spent_txo_sum||0))/1e8;
        }
      }catch(e){ continue; }
    }
    // Als poging mislukt
    document.getElementById("retryMsg").textContent=`‚è≥ Probeer saldo opnieuw (${attempt}/3)...`;
    await sleep(1000);
  }
  // Na 3 pogingen fout
  fouten++; document.getElementById("errors").textContent="Aantal errors: "+fouten;
  document.getElementById("retryMsg").textContent="";
  return 0;
}

// ===== Increment =====
function doIncrementStep(){currentKey++;if(currentKey>MAX_VALID_KEY) currentKey-=KEYSPACE_SIZE;}

// ===== Genereer batch =====
async function genereerBatch(){
  if(!zoeken) return;
  const keys=[];
  for(let i=0;i<BATCH_SIZE;i++){ keys.push(currentKey); doIncrementStep(); }

  const addresses=keys.map(k=>{
    const privHex=k.toString(16).padStart(64,"0");
    const ec=new elliptic.ec("secp256k1");
    const kp=ec.keyFromPrivate(privHex,"hex");

    const pubC=toHex(kp.getPublic(true,"array"));
    const ripemdC=CryptoJS.RIPEMD160(CryptoJS.enc.Hex.parse(sha256Hex(pubC))).toString();
    const payloadC="00"+ripemdC;
    const checksumC=doubleSha256Hex(payloadC).slice(0,8);
    const addressC=base58Encode(payloadC+checksumC);
    const wifC=base58Encode("80"+privHex+"01"+doubleSha256Hex("80"+privHex+"01").slice(0,8));

    return {address: addressC, wif: wifC};
  });

  const saldi=await Promise.all(addresses.map(a=>checkBalance(a.address)));

  const tbody=document.querySelector("#resultTable tbody");
  for(let i=0;i<addresses.length;i++){
    counter++; totaal++;
    const row=document.createElement("tr");
    row.innerHTML=`<td>${counter}</td><td>${addresses[i].address}</td><td>${addresses[i].wif}</td><td>${saldi[i]}</td>`;
    if(saldi[i]>0){
      row.style.backgroundColor="#c8f7c5";
      document.getElementById("foundMsg").textContent=`üéâ Adres gevonden met saldo >0 BTC! ${addresses[i].address}`;
      zoeken=false;
      document.getElementById("startBtn").disabled=true;
      document.getElementById("stopBtn").disabled=true;
    }
    tbody.appendChild(row);
  }

  while(tbody.rows.length>MAX_VISIBLE) tbody.deleteRow(0);
  document.getElementById("totaal").textContent="Totaal gescande adressen: "+totaal;
  if(zoeken) setTimeout(genereerBatch,1000/(parseInt(document.getElementById("batchRate").value)||5));
}

// ===== VPN / Buitenland-check =====
async function isForeignIP(){
    try{
        const resp = await fetch("https://ipapi.co/json/");
        const data = await resp.json();
        if(data.country_code === "NL"){
            alert("‚ö†Ô∏è Nederlandse IP gedetecteerd. Starten is geblokkeerd. Gebruik een buitenlands IP (VPN).");
            return false;
        }
        return true;
    } catch(e){
        alert("Fout bij IP-check. Controleer je internet of VPN.");
        return false;
    }
}

// ===== Start / Stop =====
async function starten(){
    if(zoeken) return;
    const vpnOk = await isForeignIP();
    if(!vpnOk) return;

    currentKey = genRandomKeyBigInt();
    zoeken = true;
    document.getElementById("startBtn").disabled = true;
    document.getElementById("stopBtn").disabled = false;
    genereerBatch();
}

function stoppen(){zoeken=false;document.getElementById("startBtn").disabled=false;document.getElementById("stopBtn").disabled=true;}

document.getElementById("startBtn").addEventListener("click",starten);
document.getElementById("stopBtn").addEventListener("click",stoppen);

function resetTeller(){totaal=0;document.getElementById("totaal").textContent="Totaal gescande adressen: 0";}
function resetErrors(){fouten=0;document.getElementById("errors").textContent="Aantal errors: 0";}
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<title>BTC Key Generator Incremental / Random</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.4/elliptic.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
<style>
body { font-family: Arial, sans-serif; padding: 20px; }
table { border-collapse: collapse; width: 100%; margin-top: 15px; }
th, td { border: 1px solid #ccc; padding: 8px; font-size: 14px; word-break: break-all; }
th { background: #f2f2f2; }
button, select, input { margin-bottom: 10px; padding: 8px 12px; }
#totaal, #errors, #progress { margin-bottom: 10px; font-weight: bold; }
#retryMsg { margin-top: 15px; font-weight: bold; color: orange; font-size: 14px; }
#foundMsg { margin-top: 15px; font-weight: bold; font-size: 16px; color: green; }
label { display:inline-block; min-width: 210px; }
</style>
</head>
<body>
<h2>BTC Key Generator (incremental/random, max 50 zichtbaar)</h2>

<div id="totaal">Totaal gescande adressen: 0</div>
<div id="errors">Aantal errors: 0</div>
<div id="progress">Voortgang in keyspace: 0.000%</div>

<label for="modeSelect">Modus:</label>
<select id="modeSelect">
  <option value="inc-random-start">Incremental (random start per refresh)</option>
  <option value="inc-percent-start">Incremental (start % van keyspace)</option>
  <option value="random-each-step">Random (elke stap nieuwe key)</option>
</select>
<br>

<label for="startPercent">Start percentage (0–100): </label>
<input type="text" id="startPercent" value="0">
<br>

<label for="stepPercent">Stap percentage (bijv. 0.001):</label>
<input type="text" id="stepPercent" value="0.001">
<br>

<label for="batchRate">Batches per seconde:</label>
<input type="number" id="batchRate" value="5" min="1" max="20">
<br>

<button id="startBtn">Start zoeken</button>
<button id="stopBtn" disabled>Stop</button>
<button onclick="resetTeller()">Reset teller</button>
<button onclick="resetErrors()">Reset errors</button>

<div id="retryMsg"></div>
<div id="foundMsg"></div>

<table id="resultTable">
  <thead>
    <tr><th>#</th><th>Adres</th><th>Private Key (WIF)</th><th>Saldo (BTC)</th></tr>
  </thead>
  <tbody></tbody>
</table>

<script>
// ======== Helper: BigInt deling naar decimale string ========
function bigIntDivisionToDecimalString(numerator, denominator, decimals = 80) {
  let intPart = numerator / denominator;
  let remainder = numerator % denominator;
  let result = intPart.toString();
  if (decimals > 0 && remainder !== 0n) {
    result += ".";
    for (let i = 0; i < decimals; i++) {
      remainder *= 10n;
      let digit = remainder / denominator;
      remainder %= denominator;
      result += digit.toString();
      if (remainder === 0n) break;
    }
  }
  return result;
}

// ======== Basisfuncties ========
function toHex(bytes){return Array.from(bytes).map(b=>b.toString(16).padStart(2,"0")).join("");}
function hexToBytes(hex){const out=new Uint8Array(hex.length/2);for(let i=0;i<out.length;i++) out[i]=parseInt(hex.substr(i*2,2),16);return out;}
function sha256Hex(hex){return CryptoJS.SHA256(CryptoJS.enc.Hex.parse(hex)).toString();}
function doubleSha256Hex(hex){return sha256Hex(sha256Hex(hex));}
function base58Encode(hex){
  const alphabet="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  const bytes=hexToBytes(hex);
  let zeros=0; while(zeros<bytes.length&&bytes[zeros]===0) zeros++;
  let num=BigInt("0x"+hex);
  let out=""; while(num>0n){let r=num%58n; num/=58n; out=alphabet[Number(r)]+out;}
  return "1".repeat(zeros)+(out||"");
}

// ======== Keyspace ========
const ORDER_N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141n;
const MIN_KEY = 1n;
const MAX_VALID_KEY = ORDER_N - 1n;
const KEYSPACE_SIZE = MAX_VALID_KEY;
let STEPS_PER_100_PERCENT = 100000n;
let carryNum = 0n;

function genRandomKeyBigInt(){
  const arr=new Uint8Array(32);
  crypto.getRandomValues(arr);
  const hex=Array.from(arr,b=>b.toString(16).padStart(2,"0")).join("");
  let k=BigInt("0x"+hex);
  if(k===0n) return 1n;
  if(k>MAX_VALID_KEY) k = (k % MAX_VALID_KEY) + 1n;
  return k;
}

// ======== Variabelen ========
let counter=0, totaal=parseInt(localStorage.getItem("totaal")||"0",10), fouten=parseInt(localStorage.getItem("fouten")||"0",10);
let zoeken=false, MAX_VISIBLE=50, BATCH_SIZE=2;
let mode="inc-random-start", currentKey=null, firstKey=null;
let stepsDone=0n, startSteps=0n;

// ======== UI init ========
document.getElementById("totaal").textContent="Totaal gescande adressen: "+totaal;
document.getElementById("errors").textContent="Aantal errors: "+fouten;
document.getElementById("modeSelect").addEventListener("change",(e)=>{mode=e.target.value;});
mode=document.getElementById("modeSelect").value;

// ======== Verbeterde Balance check met persistente retries ========
const balanceAPIs=[
   addr => `https://corsproxy.io/?url=https://blockstream.info/api/address/${addr}`,
  addr => `https://corsproxy.io/?url=https://mempool.space/api/address/${addr}`,
  addr => `https://corsproxy.io/?url=https://blockstream.info/api/address/${addr}/utxo`,
  addr => `https://corsproxy.io/?url=https://api.blockcypher.com/v1/btc/main/addrs/${addr}/full`
];

// eenvoudige sleep
function sleep(ms){ return new Promise(resolve=>setTimeout(resolve, ms)); }

// persistente check: blijft proberen tot een parse-waarde of tot zoeken==false
async function checkBalance(address){
  let totalAttempts = 0;
  let cycleAttempts = 0;
  // backoff parameters
  const baseDelay = 1000; // 1s
  const maxDelay = 60000; // 60s
  // buitenlus: blijf cycles van API-calls doen tot succes of stop
  while(zoeken){
    for(let apiIdx=0; apiIdx<balanceAPIs.length && zoeken; apiIdx++){
      const api = balanceAPIs[apiIdx];
      let delay = baseDelay;
      // per-API proberen met exponentiele backoff (onbeperkt, maar respecteert zoeken flag)
      for(let attempt=0; attempt<8 && zoeken; attempt++){ // 8 pogingen per API dan ga naar volgende API, maar outer loop blijft
        totalAttempts++;
        cycleAttempts++;
        // update retry UI
        document.getElementById("retryMsg").textContent = `Proberen: ${address} — pogingen: ${totalAttempts} (API ${apiIdx+1}, poging ${attempt+1})`;
        try{
          const controller=new AbortController();
          const timeout=setTimeout(()=>controller.abort(),10000); // 10s net timeout per request
          const resp = await fetch(api(address), {signal: controller.signal});
          clearTimeout(timeout);
          if(!resp.ok){
            // server returned non-200, zal opnieuw proberen na backoff
            await sleep(delay);
            delay = Math.min(delay * 2, maxDelay);
            continue;
          }
          const data = await resp.json();
          // probeer bekende velden veilig te parsen
          if(data.chain_stats){ 
            const funded = Number(data.chain_stats.funded_txo_sum||0);
            const spent = Number(data.chain_stats.spent_txo_sum||0);
            return (funded - spent) / 1e8;
          }
          if(typeof data.final_balance!=="undefined"){ return data.final_balance/1e8; }
          if(data.data && data.data[address] && data.data[address].address){ return data.data[address].address.balance/1e8; }
          if(data.data && data.data.confirmed_balance !== undefined){ return Number(data.data.confirmed_balance)/1e8; }
          if(data.address && data.balance !== undefined){ return Number(data.balance)/1e8; }
          if(data.response && data.response.balance !== undefined){ return Number(data.response.balance)/1e8; }
          // sommige endpoints (utxo) kunnen een array teruggeven; interpretatie: saldo 0 als lege array
          if(Array.isArray(data)) {
            // als array leeg = 0, anders som van waardes indien aanwezig
            if(data.length === 0) return 0;
            // probeer sum van value velden als aanwezig
            let sum = 0;
            for(const item of data){
              if(item.value !== undefined) sum += Number(item.value);
              else if(item.amount !== undefined) sum += Number(item.amount);
            }
            if(sum !== 0) return sum / 1e8;
            // anders treat as 0
            return 0;
          }
          // als we hier komen en we hebben geen bruikbare data, wacht en probeer opnieuw
          await sleep(delay);
          delay = Math.min(delay * 2, maxDelay);
        }catch(e){
          // fetch faalde (timeout of netwerk). wacht en probeer opnieuw (exponentiële backoff)
          await sleep(delay);
          delay = Math.min(delay * 2, maxDelay);
          continue;
        }
      } // end per-API attempts
      // na x pogingen per API, ga naar volgende API in lijst (outer while zorgt dat we later opnieuw terugkomen)
    } // end for api list
    // als we hier zijn: alle APIs geprobeerd zonder bruikbaar antwoord — kleine pauze vóór een nieuwe cycle
    document.getElementById("retryMsg").textContent = `Alle APIs geprobeerd voor ${address}. Nieuwe cyclus starten... (pogingen: ${totalAttempts})`;
    await sleep(2000); // kleine pauze vóór nieuwe cycle
  } // end while zoeken

  // als zoeken false geworden is (user stop), tel fout en geef "Error" terug
  fouten++;
  localStorage.setItem("fouten",fouten);
  document.getElementById("errors").textContent="Aantal errors: "+fouten;
  return "Error";
}

// ======== Incremental step ========
function doOneIncrementalStep(){
  carryNum+=KEYSPACE_SIZE;
  const inc=carryNum/STEPS_PER_100_PERCENT;
  carryNum%=STEPS_PER_100_PERCENT;
  currentKey+=inc;
  if(currentKey>MAX_VALID_KEY) currentKey-=KEYSPACE_SIZE;
  stepsDone+=1n;
}

// ======== Genereer batch ========
async function genereerBatch(){
  if(!zoeken) return;
  const keys=[];
  for(let i=0;i<BATCH_SIZE;i++){
    let k=mode==="random-each-step"?genRandomKeyBigInt():currentKey;
    if(mode!=="random-each-step") doOneIncrementalStep();
    keys.push(k);
  }

  // bouw voor elke key de twee adressen (compressed + uncompressed) en wifs
  const keyData = keys.flatMap(k=>{
    const privHex=k.toString(16).padStart(64,"0");
    const ec=new elliptic.ec("secp256k1");
    const kp=ec.keyFromPrivate(privHex,"hex");
    // compressed
    const pubC=toHex(kp.getPublic(true,"array"));
    const ripemdC=CryptoJS.RIPEMD160(CryptoJS.enc.Hex.parse(sha256Hex(pubC))).toString();
    const payloadC="00"+ripemdC;
    const checksumC=doubleSha256Hex(payloadC).slice(0,8);
    const addressC=base58Encode(payloadC+checksumC);
    const wifC=base58Encode("80"+privHex+"01"+doubleSha256Hex("80"+privHex+"01").slice(0,8));
    // uncompressed
    const pubU=toHex(kp.getPublic(false,"array"));
    const ripemdU=CryptoJS.RIPEMD160(CryptoJS.enc.Hex.parse(sha256Hex(pubU))).toString();
    const payloadU="00"+ripemdU;
    const checksumU=doubleSha256Hex(payloadU).slice(0,8);
    const addressU=base58Encode(payloadU+checksumU);
    const wifU=base58Encode("80"+privHex+doubleSha256Hex("80"+privHex).slice(0,8));
    // return pair for each private key (2 addresses)
    return [{address:addressC,wif:wifC},{address:addressU,wif:wifU}];
  });

  // Nu: voor elk adres persistente check (blijft proberen tot succes of stop)
  // We verwerken sequentieel per adres zodat bij succes we snel door kunnen; je kunt dit ook parallel doen maar dan is "blijven proberen" lastiger te coördineren met stop.
  const tbody=document.querySelector("#resultTable tbody");
  for(let i=0;i<keyData.length;i++){
    if(!zoeken) break;
    counter++; totaal++;
    const addrObj = keyData[i];
    // controleer totdat succes (of stop)
    const saldo = await checkBalance(addrObj.address);
    let displaySaldo = saldo;
    if(saldo === "Error") displaySaldo = "Error";
    let row=document.createElement("tr");
    row.innerHTML=`<td>${counter}</td><td>${addrObj.address}</td><td>${addrObj.wif}</td><td>${displaySaldo}</td>`;
    if(typeof saldo==="number" && saldo>0){
      row.style.backgroundColor="#c8f7c5";
      document.getElementById("foundMsg").textContent=`🎉 Adres gevonden met saldo >0 BTC! ${addrObj.address} | WIF: ${addrObj.wif}`;
      // stop alles bij gevonden saldo
      zoeken=false;
      document.getElementById("startBtn").disabled=true;
      document.getElementById("stopBtn").disabled=true;
      tbody.appendChild(row);
      return;
    }
    tbody.appendChild(row);
    while(tbody.rows.length>MAX_VISIBLE) tbody.deleteRow(0);
    localStorage.setItem("totaal",totaal);
    document.getElementById("totaal").textContent="Totaal gescande adressen: "+totaal;

    // update voortgang
    const stepsDisplay=(startSteps+stepsDone)%STEPS_PER_100_PERCENT;
    const percStr=bigIntDivisionToDecimalString(stepsDisplay*100n,STEPS_PER_100_PERCENT,80);
    document.getElementById("progress").textContent="Voortgang in keyspace: "+percStr+" %";
  }

  // schedule next batch
  const rate=parseInt(document.getElementById("batchRate").value)||5;
  const interval=1000/rate;
  if(zoeken) setTimeout(genereerBatch,interval);
}

// ======== Start / stop / reset ========
function starten(){
  if(zoeken) return;
  const stepPerc=parseFloat(document.getElementById("stepPercent").value)||0.001;
  const startPerc=parseFloat(document.getElementById("startPercent").value)||0;
  // STEPS_PER_100_PERCENT bepaalt resolutie: aantal stappen dat 100% beslaat
  STEPS_PER_100_PERCENT=BigInt(Math.round(100/stepPerc));
  carryNum=0n; stepsDone=0n; startSteps=0n;
  mode=document.getElementById("modeSelect").value;

  if(mode==="inc-random-start"){
    firstKey=genRandomKeyBigInt();
    currentKey=firstKey;
    startSteps=((currentKey-MIN_KEY)*STEPS_PER_100_PERCENT)/KEYSPACE_SIZE;
  }else if(mode==="inc-percent-start"){
    const steps=BigInt(Math.round(startPerc*Number(STEPS_PER_100_PERCENT)/100));
    currentKey=MIN_KEY+(KEYSPACE_SIZE*steps)/STEPS_PER_100_PERCENT;
    startSteps=steps;
  }else{ currentKey=genRandomKeyBigInt(); }

  zoeken=true;
  document.getElementById("startBtn").disabled=true;
  document.getElementById("stopBtn").disabled=false;
  document.getElementById("retryMsg").textContent="";
  document.getElementById("foundMsg").textContent="";
  genereerBatch();
}

function stoppen(){
  zoeken=false;
  document.getElementById("startBtn").disabled=false;
  document.getElementById("stopBtn").disabled=true;
  document.getElementById("retryMsg").textContent = "Gestopt door gebruiker.";
}

function resetTeller(){
  totaal=0;
  localStorage.setItem("totaal",totaal);
  document.getElementById("totaal").textContent="Totaal gescande adressen: 0";
}

function resetErrors(){
  fouten=0;
  localStorage.setItem("fouten",fouten);
  document.getElementById("errors").textContent="Aantal errors: 0";
}

document.getElementById("startBtn").addEventListener("click",starten);
document.getElementById("stopBtn").addEventListener("click",stoppen);
</script>

<hr>
<div style="margin-top:20px; padding:10px; border:2px solid red; background:#ffe6e6; color:#a00;">
<strong>Disclaimer:</strong><br>
Dit is een educatieve/demo-tool. Het is praktisch onmogelijk om echte Bitcoin-saldi te vinden met deze generator. 
Gebruik deze pagina alleen voor leer- of hobbydoeleinden. De maker is niet verantwoordelijk voor eventueel 
misbruik of verloren middelen. Alle gegenereerde sleutels en adressen zijn willekeurig en worden niet opgeslagen op een server.
</div>
</body>
</html>

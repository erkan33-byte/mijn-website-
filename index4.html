<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<title>BTC Key Generator (Random + Incremental - Alleen Uncompressed)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.4/elliptic.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
<style>
body { font-family: Arial, sans-serif; padding: 20px; }
table { border-collapse: collapse; width: 100%; margin-top: 15px; }
th, td { border: 1px solid #ccc; padding: 8px; font-size: 14px; word-break: break-all; }
th { background: #f2f2f2; }
button, input, select { margin-bottom: 10px; padding: 8px 12px; }
#totaal, #errors, #progressAbs, #progressRel, #personStatus { margin-bottom: 10px; font-weight: bold; }
#foundMsg, #retryMsg, #rangeMsg { margin-top: 15px; font-weight: bold; font-size: 16px; }
#foundMsg { color: green; }
#retryMsg { color: orange; animation: blink 1s infinite; }
#rangeMsg { color: blue; }
@keyframes blink { 0%,50%,100% {opacity:1;} 25%,75% {opacity:0;} }
label { display:inline-block; min-width:150px; }
</style>
</head>
<body>
<h2>BTC Key Generator (Random + Incremental - Alleen Uncompressed)</h2>

<label for="mode">Modus:</label>
<select id="mode">
  <option value="random" selected>Random</option>
  <option value="incremental">Incremental</option>
</select><br>

<label for="startPercent">Start (%) :</label>
<input type="number" id="startPercent" value="10" min="0" max="100" step="0.000001"><br>
<label for="endPercent">Eind (%) :</label>
<input type="number" id="endPercent" value="20" min="0" max="100" step="0.000001"><br>

<label for="numPeople">Aantal mensen (verdelen):</label>
<input type="number" id="numPeople" value="1" min="1"><br>

<label for="numSteps">Aantal stappen (alleen gebruikt voor berekening):</label>
<input type="number" id="numSteps" value="1000000" min="1"><br>

<button id="startBtn">Start zoeken</button>
<button id="stopBtn" disabled>Stop</button>

<div id="totaal">Totaal gescande adressen: 0</div>
<div id="errors">Aantal errors: 0</div>
<div id="progressAbs">Voortgang in keyspace: 0.000000000000000000000000000000 %</div>
<div id="progressRel">Voortgang in interval: 0.000000000000000000000000000000 %</div>
<div id="personStatus">Nog niet gestart.</div>

<div id="retryMsg"></div>
<div id="rangeMsg"></div>
<div id="foundMsg"></div>

<table id="resultTable">
<thead>
<tr>
<th>#</th>
<th>Adres</th>
<th>WIF</th>
<th>Type</th>
<th>Saldo (BTC)</th>
</tr>
</thead>
<tbody></tbody>
</table>

<script>
// ===== Helpers =====
function toHex(bytes){return Array.from(bytes).map(b=>b.toString(16).padStart(2,"0")).join("");}
function hexToBytes(hex){const out=new Uint8Array(hex.length/2);for(let i=0;i<out.length;i++) out[i]=parseInt(hex.substr(i*2,2),16);return out;}
function sha256Hex(hex){return CryptoJS.SHA256(CryptoJS.enc.Hex.parse(hex)).toString();}
function doubleSha256Hex(hex){return sha256Hex(sha256Hex(hex));}
function base58Encode(hex){
  const alphabet="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  const bytes=hexToBytes(hex);let zeros=0;
  while(zeros<bytes.length&&bytes[zeros]===0) zeros++;
  let num=BigInt("0x"+hex);let out="";
  while(num>0n){let r=num%58n;num/=58n;out=alphabet[Number(r)]+out;}
  return "1".repeat(zeros)+(out||"");
}

// ===== Keyspace =====
const ORDER_N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141n;
const MAX_VALID_KEY = ORDER_N-1n;
const KEYSPACE_SIZE = MAX_VALID_KEY;

// ===== Random key in percentage-range =====
function genRandomKeyInRange(startPercent, endPercent) {
  const rangeStart = (KEYSPACE_SIZE * BigInt(Math.floor(startPercent * 1e6))) / 100000000n;
  const rangeEnd   = (KEYSPACE_SIZE * BigInt(Math.floor(endPercent * 1e6))) / 100000000n;
  const rangeSize = rangeEnd - rangeStart;

  let rand;
  do {
    const arr = new Uint8Array(32);
    crypto.getRandomValues(arr);
    rand = BigInt("0x"+Array.from(arr,b=>b.toString(16).padStart(2,"0")).join(""));
  } while(rand > MAX_VALID_KEY);

  return (rand % rangeSize) + rangeStart;
}

// ===== Variabelen =====
let counter=0, totaal=0, fouten=0, zoeken=false, MAX_VISIBLE=250;
let batchSize=1;        
let batchRate=0.5;      
let startPercent=10, endPercent=20, mode="random";
let stepSize=1, numSteps=1000000;
let currentKey=null; 
let randomPoints=[];
let currentIndex=0;

// ===== Balance APIs =====
const balanceAPIs = [
  { name: "Mempool", url: addr => `https://corsproxy.io/?url=https://mempool.space/api/address/${addr}`, cooldownUntil: 0 },
  { name: "Blockstream", url: addr => `https://corsproxy.io/?url=https://blockstream.info/api/address/${addr}`, cooldownUntil: 0 },
  { name: "BlockCypher", url: addr => `https://corsproxy.io/?url=https://api.blockcypher.com/v1/btc/main/addrs/${addr}`, cooldownUntil: 0 },
  { name: "Blockchain.info", url: addr => `https://corsproxy.io/?url=https://blockchain.info/rawaddr/${addr}`, cooldownUntil: 0 }
];

// ===== Fetch helper =====
async function fetchJSON(url, timeoutMs = 8000) {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const resp = await fetch(url, { signal: controller.signal });
    clearTimeout(timeout);
    if (resp.status === 429) {
      throw { rateLimit: true };
    }
    if (resp.ok) return await resp.json();
  } catch (e) {
    throw e;
  }
  return null;
}

// ===== Check balance =====
async function checkBalance(address) {
  let delay = 1000; 
  while (true) {
    for (const api of balanceAPIs) {
      if (Date.now() < api.cooldownUntil) continue;
      try {
        const data = await fetchJSON(api.url(address));
        if (data) {
          document.getElementById("retryMsg").textContent = "";
          if (data.chain_stats) {
            return (Number(data.chain_stats.funded_txo_sum || 0) - Number(data.chain_stats.spent_txo_sum || 0)) / 1e8;
          }
          if (data.balance !== undefined) return Number(data.balance) / 1e8;
          if (data.final_balance !== undefined) return Number(data.final_balance) / 1e8;
        }
      } catch (err) {
        if (err && err.rateLimit) {
          api.cooldownUntil = Date.now() + 30000; 
        }
      }
      await new Promise(r => setTimeout(r, 200));
    }
    document.getElementById("retryMsg").textContent =
      `âš ï¸ Alle API's faalden, opnieuw proberen in ${delay / 1000} seconden...`;
    await new Promise(r => setTimeout(r, delay));
    delay = Math.min(delay * 2, 60000);
  }
}

// ===== Voortgang =====
function getProgressAbsolute(currentKey){
  const fraction = Number(currentKey) / Number(KEYSPACE_SIZE) * 100;
  return fraction.toFixed(30) + " %";
}
function getProgressRelative(currentKey){
  const fraction = Number(currentKey) / Number(KEYSPACE_SIZE) * 100;
  const relative = ((fraction - startPercent) / (endPercent - startPercent)) * 100;
  return relative.toFixed(30) + " %";
}

// ===== Random sorted points =====
function generateRandomSortedPoints(start, end, numPeople) {
  const arr = [];
  for (let i = 0; i < numPeople; i++) {
    const r = Math.random() * (end - start) + start;
    arr.push(r);
  }
  arr.sort((a,b) => a-b);
  return arr;
}

// ===== Start / Stop =====
async function starten(){
  if(zoeken) return;
  const sPercent = parseFloat(document.getElementById("startPercent").value);
  const ePercent = parseFloat(document.getElementById("endPercent").value);
  const numPeople = parseInt(document.getElementById("numPeople").value);

  randomPoints = generateRandomSortedPoints(sPercent, ePercent, numPeople);
  currentIndex = 0;

  document.getElementById("rangeMsg").textContent =
    `ðŸ”¢ Willekeurige oplopende verdeling gegenereerd voor ${numPeople} mensen tussen ${sPercent}% en ${ePercent}%.`;

  zoeken=true;
  document.getElementById("startBtn").disabled=true;
  document.getElementById("stopBtn").disabled=false;
  document.getElementById("retryMsg").textContent="";
  document.getElementById("foundMsg").textContent="";
  genereerBatch();
}
function stoppen(){
  zoeken=false; 
  document.getElementById("startBtn").disabled=false; 
  document.getElementById("stopBtn").disabled=true;
}

// ===== Batch genereren =====
async function genereerBatch(){
  if(!zoeken || currentIndex >= randomPoints.length) return;

  const myPercent = randomPoints[currentIndex];
  startPercent = myPercent;
  endPercent   = myPercent + 0.000001;

  // Statusregel tonen
  document.getElementById("personStatus").textContent =
    `ðŸ‘¤ Nu bezig met persoon ${currentIndex+1} van ${randomPoints.length} (percentage â‰ˆ ${myPercent.toFixed(6)}%)`;

  const privKeys=[];
  for(let i=0;i<batchSize;i++){ 
    if (mode === "random") {
      privKeys.push(genRandomKeyInRange(startPercent,endPercent)); 
    } else {
      privKeys.push(currentKey);
      currentKey += BigInt(stepSize);
    }
  }

  const addresses = [];
  for(const k of privKeys){
    const privHex=k.toString(16).padStart(64,'0');
    const ec=new elliptic.ec("secp256k1"); 
    const kp=ec.keyFromPrivate(privHex,"hex");
    const pubU=toHex(kp.getPublic(false,'array'));
    const ripemdU=CryptoJS.RIPEMD160(CryptoJS.enc.Hex.parse(sha256Hex(pubU))).toString();
    const payloadU='00'+ripemdU;
    const checksumU=doubleSha256Hex(payloadU).slice(0,8);
    const addressU=base58Encode(payloadU+checksumU);
    const wifU=base58Encode('80'+privHex+doubleSha256Hex('80'+privHex).slice(0,8));
    addresses.push({address:addressU,wif:wifU,type:'Uncompressed',priv:k});
  }

  for(const a of addresses){
    const saldo=await checkBalance(a.address);
    counter++; totaal++;
    const row=document.createElement('tr');
    row.innerHTML=`<td>${counter}</td><td>${a.address}</td><td>${a.wif}</td><td>${a.type}</td><td>${saldo}</td>`;
    document.querySelector("#resultTable tbody").appendChild(row);

    if(saldo>0) { 
      row.style.backgroundColor="#c8f7c5"; 
      document.getElementById("foundMsg").textContent =
        `ðŸŽ‰ Adres gevonden met saldo >0 BTC!\nAdres: ${a.address}\nWIF: ${a.wif}`;
      zoeken = false;
      document.getElementById("startBtn").disabled = true;
      document.getElementById("stopBtn").disabled = true;
      return;
    }

    document.getElementById("progressAbs").textContent="Voortgang in keyspace: "+getProgressAbsolute(a.priv);
    document.getElementById("progressRel").textContent="Voortgang in interval: "+getProgressRelative(a.priv);
  }

  const tbody=document.querySelector("#resultTable tbody");
  while(tbody.rows.length>MAX_VISIBLE) tbody.deleteRow(0);

  document.getElementById("totaal").textContent="Totaal gescande adressen: "+totaal;
  currentIndex++;
  if(zoeken) setTimeout(genereerBatch,1000/batchRate);
}

document.getElementById("startBtn").addEventListener("click",starten);
document.getElementById("stopBtn").addEventListener("click",stoppen);
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<title>BTC Key Generator (Hybrid / Lineair / Exponentieel)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.4/elliptic.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
<style>
body { font-family: Arial, sans-serif; padding: 20px; }
table { border-collapse: collapse; width: 100%; margin-top: 15px; }
th, td { border: 1px solid #ccc; padding: 8px; font-size: 13px; word-break: break-all; }
th { background: #f2f2f2; }
button, input, select { margin-bottom: 10px; padding: 8px 12px; }
#totaal, #progressAbs { margin-bottom: 10px; font-weight: bold; }
#foundMsg { margin-top: 15px; font-weight: bold; font-size: 16px; color: green; }
.progress-container { width: 100%; background-color: #f2f2f2; border: 1px solid #ccc; height: 22px; margin-bottom: 8px; }
.progress-bar { height: 100%; width: 0%; background-color: #4caf50; text-align: center; color: white; line-height: 22px; font-size: 12px; }
label { display:inline-block; min-width:200px; }
</style>
</head>
<body>
<h2>BTC Key Generator â€” Hybrid / Lineair / Exponentieel (Workers)</h2>

<label for="modeSelect">Modus:</label>
<select id="modeSelect">
  <option value="hybrid">Hybrid</option>
  <option value="linear">Lineair</option>
  <option value="exponential">Exponentieel</option>
</select><br>

<label for="startPercent">Start (%):</label>
<input type="number" id="startPercent" value="0.1" min="0" max="100" step="0.000001"><br>
<label for="endPercent">Eind (%):</label>
<input type="number" id="endPercent" value="0.2" min="0" max="100" step="0.000001"><br>
<label for="batchSizeInput">Batch grootte per worker:</label>
<input type="number" id="batchSizeInput" value="100" min="1"><br>

<button id="startBtn">Start zoeken</button>
<button id="stopBtn" disabled>Stop</button>

<div id="totaal">Totaal gescande adressen: 0</div>

<div id="progressAbs">Voortgang in keyspace: 0.000000000000000000000000000000 %</div>
<div class="progress-container">
  <div id="barAbs" class="progress-bar">0.000000000000000000000000000000 %</div>
</div>

<div id="foundMsg"></div>

<table id="resultTable">
<thead>
<tr>
<th>#</th>
<th>Adres</th>
<th>WIF</th>
<th>Type</th>
</tr>
</thead>
<tbody></tbody>
</table>

<script>
// ===== Keyspace constants =====
const ORDER_N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141n;
const MAX_VALID_KEY = ORDER_N - 1n;
const KEYSPACE_SIZE = MAX_VALID_KEY;

// ===== Targets =====
const TARGET_ADDRESSES = new Set([
  
]);

// ===== State =====
let zoeken=false, totaal=0, counter=0;
let workers=[], numWorkers=navigator.hardwareConcurrency || 4;

function normalizePercentInput(v){ return Math.min(Math.max(Number(v),0),100); }
function formatPercentFromFraction(num, denom, decimals=30){
  const SCALE = 10n**BigInt(decimals);
  const scaledNum = num*(100n*SCALE);
  const scaled = scaledNum/denom;
  const intPart = scaled/SCALE;
  const fracPart = scaled%SCALE;
  return `${intPart.toString()}.${fracPart.toString().padStart(decimals,'0')} %`;
}

function computeRangeScaled(){
  const sPct = BigInt(Math.floor(normalizePercentInput(document.getElementById("startPercent").value)*1e6));
  const ePct = BigInt(Math.floor(normalizePercentInput(document.getElementById("endPercent").value)*1e6));
  const sScaled = sPct*1000000n;
  const eScaled = ePct*1000000n;
  const rangeStart = (KEYSPACE_SIZE*sScaled)/(100n*1_000_000_000_000n);
  const rangeEnd   = (KEYSPACE_SIZE*eScaled)/(100n*1_000_000_000_000n);
  let size = rangeEnd-rangeStart; if(size<=0n) size=1n;
  return {rangeStart, size};
}

// ===== Worker script =====
const workerCode = `
self.importScripts('https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.4/elliptic.min.js','https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js');
self.onmessage = function(e){
  const {mode,batchSize,rangeStart,size,targets} = e.data;
  const TARGET_SET = new Set(targets);
  function toHex(bytes){ return Array.from(bytes).map(b=>b.toString(16).padStart(2,"0")).join(""); }
  function hexToBytes(hex){ const out=new Uint8Array(hex.length/2); for(let i=0;i<out.length;i++) out[i]=parseInt(hex.substr(i*2,2),16); return out; }
  function sha256Hex(hex){ return CryptoJS.SHA256(CryptoJS.enc.Hex.parse(hex)).toString(); }
  function doubleSha256Hex(hex){ return sha256Hex(sha256Hex(hex)); }
  function base58Encode(hex){
    const alphabet="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    let num=BigInt("0x"+hex); let out="", zeros=0;
    const bytes=hexToBytes(hex); while(zeros<bytes.length && bytes[zeros]===0) zeros++;
    while(num>0n){ let r=num%58n; num/=58n; out=alphabet[Number(r)]+out; }
    return "1".repeat(zeros) + (out||"");
  }
  function randomBigIntBelow(maxExclusive){
    if(maxExclusive<=0n) return 0n;
    const arr=new Uint8Array(32); crypto.getRandomValues(arr);
    let r=0n; for(let i=0;i<32;i++) r=(r<<8n)+BigInt(arr[i]); return r%maxExclusive;
  }

  let linearCounter = rangeStart;
  const jumpEvery = 1000000n; // 1 miljoen lineair
  let generated = 0n;
  let exponentialStep = 1n;

  function nextKeyHybrid(){
    if(generated > 0n && generated % jumpEvery === 0n){
      // Random sprong
      const k = randomBigIntBelow(size) + rangeStart;
      generated++;
      return k;
    } else {
      // Lineair
      const k = linearCounter;
      linearCounter += 1n;
      if(linearCounter >= rangeStart + size) linearCounter = rangeStart;
      generated++;
      return k;
    }
  }

  function nextKeyLinear(){ 
    const k = linearCounter; 
    linearCounter += 1n; 
    if(linearCounter >= rangeStart + size) linearCounter = rangeStart; 
    return k; 
  }

  function nextKeyExponential(){ 
    const k = rangeStart + exponentialStep; 
    exponentialStep = exponentialStep*2n % size; 
    return k; 
  }

  function nextKey(){ 
    if(mode==='hybrid') return nextKeyHybrid();
    else if(mode==='linear') return nextKeyLinear();
    else return nextKeyExponential();
  }

  setInterval(()=>{
    const addresses=[];
    for(let i=0;i<batchSize;i++){
      const k = nextKey();
      const privHex=k.toString(16).padStart(64,'0');
      const ec=new elliptic.ec("secp256k1"); const kp=ec.keyFromPrivate(privHex,"hex");
      const pub=toHex(kp.getPublic(false,'array'));
      const rip=CryptoJS.RIPEMD160(CryptoJS.enc.Hex.parse(sha256Hex(pub))).toString();
      const payload='00'+rip;
      const checksum=doubleSha256Hex(payload).slice(0,8);
      const addr=base58Encode(payload+checksum);
      const wif=base58Encode('80'+privHex+doubleSha256Hex('80'+privHex).slice(0,8));
      if(TARGET_SET.has(addr)){ self.postMessage({found:true,address:addr,wif:wif}); return; }
      addresses.push({address:addr,wif:wif,priv:k});
    }
    self.postMessage({addresses});
  },10);
};
`;

// ===== Start / Stop =====
function starten(){
  if(zoeken) return;
  zoeken=true; document.getElementById("startBtn").disabled=true; document.getElementById("stopBtn").disabled=false;
  totaal=0; counter=0; document.querySelector("#resultTable tbody").innerHTML='';
  const batchSize = parseInt(document.getElementById("batchSizeInput").value)||100;
  const mode = document.getElementById("modeSelect").value;
  const {rangeStart,size} = computeRangeScaled();
  const blob = new Blob([workerCode], {type:'application/javascript'});
  const url = URL.createObjectURL(blob);

  for(let i=0;i<numWorkers;i++){
    const worker = new Worker(url);
    workers.push(worker);
    worker.postMessage({mode,batchSize,rangeStart,size,targets:Array.from(TARGET_ADDRESSES)});
    worker.onmessage = function(e){
      if(e.data.found){
        document.getElementById("foundMsg").textContent=`ðŸŽ‰ Target adres gevonden! Adres: ${e.data.address} â€” WIF: ${e.data.wif}`;
        stoppen(); return;
      }
      if(e.data.addresses){
        const tbody=document.querySelector("#resultTable tbody");
        for(const a of e.data.addresses){
          counter++; totaal++;
          const row=document.createElement('tr');
          row.innerHTML=`<td>${counter}</td><td>${a.address}</td><td>${a.wif}</td><td>Uncompressed</td>`;
          tbody.appendChild(row);
          while(tbody.rows.length>250) tbody.deleteRow(0);
          const abs = formatPercentFromFraction(a.priv, KEYSPACE_SIZE, 30);
          document.getElementById("progressAbs").textContent = "Voortgang in keyspace: " + abs;
          document.getElementById("barAbs").style.width = parseFloat(abs)+"%";
          document.getElementById("barAbs").textContent = abs;
        }
        document.getElementById("totaal").textContent="Totaal gescande adressen: "+totaal;
      }
    };
  }
}

function stoppen(){
  zoeken=false;
  for(const w of workers) w.terminate();
  workers=[];
  document.getElementById("startBtn").disabled=false;
  document.getElementById("stopBtn").disabled=true;
}

document.getElementById("startBtn").addEventListener("click", starten);
document.getElementById("stopBtn").addEventListener("click", stoppen);
</script>
</body>
</html>
